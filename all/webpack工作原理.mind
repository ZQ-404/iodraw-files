{"root":{"data":{"id":"czv6yr12qv40","created":1710594000045,"text":"webpack工作原理"},"children":[{"data":{"id":"czv71nd5fnk0","created":1710594227160,"text":"webpack打包的流程？","note":"webpack 是一个串行过程，它的工作流程就是将各个插件串联起来。\n\nwebpack 的构建流程：\n1、初始化流程：配置文件中读取参数、shell 语句合并参数、初始化插件在执行环境中所需要的参数；\n2、编译构建流程：从 Entry 发出，调用对应 Loader 去翻译文件内容，在找到对应 Module 去递归编译处理；\n3、输出流程：编译之后 Module 组合成 Chunk，把 Chunk 转换成文件，输出文件系统。\n\n\n整个的生命周期：\nentry-option ：初始化 option\nrun\ncompile： 真正开始的编译，在创建 compilation 对象之前\ncompilation ：生成好了 compilation 对象\nmake 从 entry 开始递归分析依赖，准备对每个模块进行 build\nafter-compile： 编译 build 过程结束\nemit ：在将内存中 assets 内容写到磁盘文件夹之前\nafter-emit ：在将内存中 assets 内容写到磁盘文件夹之后\ndone： 完成所有的编译过程\nfailed： 编译失败的时候\n\n\n\n"},"children":[]},{"data":{"id":"czv71qod47k0","created":1710594234369,"text":"说一下webpack Loader","note":"webpack中的\n\n\nLoader特性：\n\n\n常见的Loader："},"children":[{"data":{"id":"czxdfnwptlk0","created":1710815372015,"text":"Loader是什么","note":"loader 是文件加载器，能够加载资源文件，并对css、sass、png等文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中"},"children":[]},{"data":{"id":"czxdfv2fvbc0","created":1710815387598,"text":"Loader特性","note":"loader支持链式调用，最终变为js代码。\nloader 可以是同步的，也可以是异步的。\nloader 运行在 Node.js 中，并且能够执行任何操作。\nloader 能够产生额外的任意文件。\n可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。压缩、打包、语言翻译和更多其他特性。"},"children":[]},{"data":{"id":"czxdfxxijbc0","created":1710815393831,"text":"常见的Loader","note":"style-loader: 将css添加到DOM的内联样式标签style里。\n\ncss-loader :允许将css文件通过require的方式引入，并返回css代码\n\nless-loader: 处理less\n\nsass-loader: 处理sass\n\npostcss-loader: 用postcss来处理CSS\n\nfile-loader: 分发文件到output目录并返回相对路径\n\nurl-loader: 和file-loader类似，但是当文件小于设定的limit时可以返回一个Data Url\n\nhtml-minify-loader: 压缩HTML\n\nbabel-loader :用babel来转换ES6文件到ES\n\n\n\n"},"children":[]}]},{"data":{"id":"czv71utfcoo0","created":1710594243382,"text":"说一下webpack Plugin"},"children":[{"data":{"id":"czxdq42nlr40","created":1710816190844,"text":"Plugin是什么","note":"plugin为webpack赋予各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的在于解决loader 无法实现的其他事。它们会运行在 webpack 的不同周期。\n\n"},"children":[]},{"data":{"id":"czxdq8x3vo80","created":1710816201392,"text":"Plugin特性","note":"其本质是一个具有apply方法javascript对象。\n整个编译生命周期都可以使用compiler对象去调用apply 方法。"},"children":[]},{"data":{"id":"czxdqf75z340","created":1710816215061,"text":"常见的Plugin","note":"HtmlWebpackPlugin，⾃动生成⼀个 html ⽂文件，并把打包生成的js 模块引⼊到该 html 中。\n\n\nclean-webpack-plugin删除旧的构建目录\n\nmini-css-extract-plugin提取 CSS 到一个单独的文件中\n\n\nDefinePlugin一个webpack内置的插件，不需要安装，允许在编译时创建配置的全局对象。\n\n\ncopy-webpack-plugin复制文件或目录到执行区域，"},"children":[]}]},{"data":{"id":"czxdei2ue5s0","created":1710815280960,"text":"webpack loader 和 plugin区别？","layout_mind_offset":{"x":-10,"y":0},"note":"1、运行时间上的区别：\nloader 运行在打包文件之前。\nplugins 在整个编译周期都起作用。\n\n\n2、工作实质的区别：\nloader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程。\n\nPlugin 可以监听这Webpack 运行的生命周期中许多事件，在合适的时机通过Webpack提供的 API改变输出结果。\n\n\n如何编写Loader(保持Loader功能的单一性）\nLoader本质是一个函数，source为webpack传递给loader的文件源内容\nmodule.exports = function(source) {\n//对文件进行操作\n const content = doSomeThing2JsString(source);\n //接收loader配置的options对象\n const options = this.query;\n this.callback(null, content); // 异步操作通过callback返回\tString 或者 Buffer，\n return content; // 同步\n }\n \n 编写plugin\n 核心对象有两个一个是complier 一个是compilation。\n complier包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子.\n compilation: 当前打包构建流程的上下文。\n \n 例子\n 插件必须是一个函数或者是一个包含 apply 方法的类、\n class MyPlugin {\n    // Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象\n  apply (compiler) {\n    // 找到合适的事件钩子，实现自己的插件功能\n    compiler.hooks.emit.tap('MyPlugin', compilation => {\n        // compilation: 当前打包构建流程的上下文\n        console.log(compilation);\n        \n        // do something...\n    })\n  }\n}\n "},"children":[]},{"data":{"id":"czxdef1ekw00","created":1710815274343,"text":"webpack热更新原理？"},"children":[{"data":{"id":"czxein0nchc0","created":1710818426278,"text":"热更新是什么","note":"指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。\n（局部刷新，保存页面的状态信息）\n\n怎么配置？\nconst webpack = require('webpack')\nmodule.exports = {\n  // ...\n  devServer: {\n    // 开启 HMR 特性\n    hot: true\n    // hotOnly: true\n  }\n}"},"children":[]},{"data":{"id":"czxeiw8503s0","created":1710818446322,"text":"实现原理","note":"webpack-dev-server两个对象\nsocket serve    websocket 的长连接，双方可以通信\nexpress serve   直接提供静态资源的服务\n\n初次启动阶段：\nWebpack Compile 将源代码和 HMR Runtime 一起编译成 bundle.js文件，传输给Bundle Server（webpack  dev serve） 静态资源服务器\n\n更新阶段：\nsocket server 监听到对应的模块发生变化时，重新编译打包，编译生成两个文件manifest.json（manifest文件，包含了 hash（唯一的下一次热更新的标识hash值） 和 chundId，用来说明变化的内容））和chunk.js文件（update chunk）。以及一个hash标识\n\n浏览器发现hash 发生变化，创建一个 ajax 去服务端请求获取到变化内容的 manifest 文件。\n浏览器根据 manifest 文件获取模块变化的内容，从而触发render流程。\nsocket server 可以直接将这两个文件主动发送给客户端（浏览器），也就是从HMR Server（webpack dev  serve） 发送给   HMR Runtime（浏览器）runtime机制，加载这两个文件，并且针对修改的模块进行更新"},"children":[]}]},{"data":{"id":"czxfenkwv4w0","created":1710820935156,"text":"webpack 的proxy是什么","note":"即webpack提供的代理服务，接收客户端发送的请求后转发给其他服务器。\n目的就是为了解决开发者在开发模式下的跨域问题。\nwebpack-dev-server只适用在开发阶段，配置代码如下：\ndevServer: {\n        contentBase: path.join(__dirname, 'dist'),\n        compress: true,\n        port: 9000,\n        proxy: {\n            '/api': {\n                target: 'https://api.github.com'\n            }\n        }"},"children":[{"data":{"id":"czxfhn3zw540","created":1710821169226,"text":"工作原理","note":"实质上是利用http-proxy-middleware 这个http代理中间件。\n\n\n服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制\n该浏览器发送一个前缀带有/api标识的请求到服务端获取数据，服务器只是将请求转发到另一台服务器中"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}