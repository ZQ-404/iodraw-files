{"root":{"data":{"id":"d005x0gbwio0","created":1711098842503,"text":"计算机网络"},"children":[{"data":{"id":"d006l73dxw80","created":1711100737698,"text":"http状态码"},"children":[{"data":{"id":"d006o43e1uo0","created":1711100966260,"text":"常见的状态码"},"children":[]},{"data":{"id":"d006o7ezig80","created":1711100973492,"text":"重定向状态302、303、307的区别"},"children":[]}]},{"data":{"id":"d006lbfp7a80","created":1711100747150,"text":"DNS"},"children":[{"data":{"id":"d006om1nc480","created":1711101005337,"text":"DNS协议是什么"},"children":[]},{"data":{"id":"d006orfxv940","created":1711101017085,"text":"DNS同时使用TCP和UDP协议？"},"children":[]},{"data":{"id":"d006p23bi140","created":1711101040267,"text":"DNS完整的查询过程"},"children":[]},{"data":{"id":"d006p7grrog0","created":1711101051964,"text":"迭代查询和递归查询"},"children":[]},{"data":{"id":"d006pdcpuqw0","created":1711101064780,"text":"DNS记录和报文"},"children":[]}]},{"data":{"id":"d006ld6jie80","created":1711100750950,"text":"网络模型"},"children":[{"data":{"id":"d006pnxvz2w0","created":1711101087828,"text":"OSI七层网络模型"},"children":[]},{"data":{"id":"d006pt3sw480","created":1711101099069,"text":"TCP/IP五层网络模型"},"children":[]}]},{"data":{"id":"d006lkl3b7s0","created":1711100767067,"text":"TCP和UDP","layout_mind_offset":{"x":-12.999999612569809,"y":75.99999836087227}},"children":[{"data":{"id":"d006q5do5eo0","created":1711101125787,"text":"TCP和UDP的概念和特点"},"children":[]},{"data":{"id":"d006qbxr5a00","created":1711101140062,"text":"TCP和UDP的区别"},"children":[]},{"data":{"id":"d006qiu99x40","created":1711101155088,"text":"TCP和UDP的使用场景"},"children":[]},{"data":{"id":"d006qpek6ns0","created":1711101169377,"text":"UDP协议为什么不可靠"},"children":[]},{"data":{"id":"d006qtzazqw0","created":1711101179338,"text":"TCP的重传机制"},"children":[]},{"data":{"id":"d006qy30pm80","created":1711101188270,"text":"TCP的拥塞控制机制"},"children":[]},{"data":{"id":"d006r34ltts0","created":1711101199250,"text":"TCP的流量控制机制"},"children":[]},{"data":{"id":"d006r9eqmzs0","created":1711101212923,"text":"TCP的可靠传输机制"},"children":[]},{"data":{"id":"d006rf7fei00","created":1711101225542,"text":"TCP的三次握手四次挥手"},"children":[]},{"data":{"id":"d006rn5w1eo0","created":1711101242863,"text":"TCP粘包是怎么回事，怎么处理"},"children":[]},{"data":{"id":"d006rulxnso0","created":1711101259071,"text":"为什么UDP不会粘包"},"children":[]}]},{"data":{"id":"d006lllclnk0","created":1711100769259,"text":"websocket","layout_mind_offset":{"x":736.9999780356887,"y":890.9999857246879}},"children":[{"data":{"id":"d006s4vrjlc0","created":1711101281433,"text":"对websocket的理解"},"children":[]},{"data":{"id":"d006sbhd1o80","created":1711101295799,"text":"短轮询、长轮询、SSE和websocket的区别"},"children":[]}]},{"data":{"id":"d006lmeqpnk0","created":1711100771036,"text":"HTTP协议"},"children":[{"data":{"id":"d006syrx9pc0","created":1711101346504,"text":"GET和POST的区别","note":"是否缓存：一般 对 Get 进行缓存，post 很少缓存\n安全性：get 如果以 url 形式传递参数的时候，url 会在历史记录中，相对报文传输不安全\n\n应用场景下的区别：Get 主要在幂等操作上，趋向于获取资源，不对资源进行操作。Post 则是趋向于对数据库资源的修改和删除。\n\n报文主体格式：get 报文主体一般为空，post 主体不为空\n\n参数请求长度：url 的长度在浏览器中是有范围的（不同的浏览器范围不同，414 长度超标时，服务器会这样标注），限制了 get 的请求参数\n\n参数数据类型：post 支持更多的数据类型，get 只允许%符号转换之后的编码格式\n"},"children":[]},{"data":{"id":"d006t34lwyg0","created":1711101355978,"text":"POST和PUT的区别","note":"Put 倾向于修改数据\nPost 倾向于创建数据"},"children":[]},{"data":{"id":"d006tfw0q3k0","created":1711101383757,"text":"常见的HTTP请求头和响应头","note":"HTTP Request Header 常见的请求头\nAccept:浏览器能够处理的内容类型\nAccept-Charset:浏览器能够显示的字符集\nAccept-Encoding：浏览器能够处理的压缩编码\nAccept-Language：浏览器当前设置的语言\nConnection：浏览器与服务器之间连接的类型\nCookie：当前页面设置的任何 Cookie\nHost：发出请求的页面所在的域\nReferer：发出请求的页面的 URL\nUser-Agent：浏览器的用户代理字符串\n\n\nHTTP Response Header 常见的响应头\nDate：表示消息发送的时间，时间的描述格式由 rfc822 定义\nserver:服务器名称\nConnection：浏览器与服务器之间连接的类型\nCache-Control：控制 HTTP 缓存\ncontent-type:表示后面的文档属于什么 MIME 类型\n"},"children":[]},{"data":{"id":"d039vww1yx40","created":1711414720692,"text":"常见的content-type","note":"application/x-www-form-urlencoded\napplication/form-data\napplication/josn\ntext/xml"},"children":[]},{"data":{"id":"d006tou9vew0","created":1711101403243,"text":"HTTP状态码304多好、还是少好","note":"对于服务器来说，304 变多，可以减轻他的压力。\n但是对于搜索引擎蜘蛛，当一个网页出现更新停滞时，他的排名就序就会靠后，在搜索引擎蜘蛛这里就显得不友好。\n\n304 变多的原因：\n静态页面、强制静态页面\n页面长期不更新或者更新周期变长\n\n\n304 状态会造成问题\n网站快照停止\n权重下降\n收录减少"},"children":[]},{"data":{"id":"d006txy58h40","created":1711101423068,"text":"常见的HTTP请求方法","note":"get 获取\npost 创建\nput 修改\ndelete 删除\nhead 获取报文首部 ，与 get 相比，不返回主体部分\noptions 询问服务器支持请求的方法，用来跨域请求\nconnect 和代理服务器建立隧道的时候，使用隧道建立 TCP 链接（代理服务器：浏览器和服务器之间的中转站）\ntrace 回显服务器收到的请求，主要测试或诊断"},"children":[]},{"data":{"id":"d006u4idqko0","created":1711101437352,"text":"Options请求方法和使用场景","note":"主要用途有两个：\n获取服务器支持的请求方式；\n检查资源访问权限。CORS 跨域资源共享时 需要判断指定资源的访问权限 （服务端是否设置了 Access-Control-Allow-Origin ）"},"children":[]},{"data":{"id":"d006uszcbzs0","created":1711101490620,"text":"HTTP1.0 和HTTP1.1 的区别","note":"① 连接：http1.0 默认非持久连接； http1.1 默认使用长久连接。\n② 资源请求方面：http1.0 中，每次请求资源的时候，传输的是整个资源对象；http1.1 请求头引入了 range 头域，状态码是 206；便于自由选择，充分利用宽带和连接。\n③ 缓存上面：1.0 缓存机制 if-modified-since expires；1.1 引入了更多了缓存策略 etag 、if-unmodified-since 、if-match 、 if-none-match 对缓存的判断更加准确。\n④http1.1 新增了 host 字段，用来指定服务器域名。但是 1.0 是没有的。1.0 认为一台服务器只有一个 IP 地址，但是随着技术发展，一台物理服务器上会存在多个虚拟机，共用一个 IP。有了 host 就好区分了。\n⑤http1.1 相对 http1.0 新增请求方法如 put head options connect trace"},"children":[]},{"data":{"id":"d006uytb6800","created":1711101503316,"text":"HTTP1.1和HTTP2.0 的区别","note":"①2.0 头信息帧 和数据帧，全是二进制；1.1 头部必须是文本（%符号编码），数据体可以是\n②2.0 多路复用，（一个信道同时传输传输多路信号，即同时传输多条请求和响应），避免队头堵塞\n③ 数据流。响应的时候资源在传输的时候被分成数据包，并且数据包是不按照顺序发送的。这些数据包就叫做一个数据流，每个数据流都有一个独一无二的编号。区分数据包属于哪个数据流\n④ 头信息压缩：头部信息使用 gzip 或 compress 压缩后再发送，节约宽带，降低速度。另外客户端和服务端都维护了一张表，头部信息字段和索引，\n这样下次发请求的时候只需要发送索引号，可提高速度。\n⑤ 服务器推送：http2 在客户端没有请求的情况加可以直接向客户推送“静态资源”。和 WebSocket 以及使用 SSE 数据推送是，不一样的\n⑥ 队头堵塞：队列先进先出，如果队头堵塞的时候耽误了，后面的请求承担不了时间成本就会造成队头堵塞"},"children":[]},{"data":{"id":"d03a7xsizrs0","created":1711415663026,"text":"http与HTTPS的区别","note":"①HTTPS 协议需要 CA 证书，费用高；而 HTTP 协议不需要\n②HTTP 是明文传输，HTTPS 是具有安全性的 ssl 加密传输\n③ 链接方式和默认端口不同 http80 HTTPS 443\n④ HTTP 很简单； HTTPS 是由 SSL 和 HHTP 构建，可以进行加密传输、身份认证。比 http 更加安全"},"children":[]},{"data":{"id":"d006v4nzwvs0","created":1711101516056,"text":"GET方法URL限制的方法","note":"其实 http 并没有对 get 的请求进行限制\n主要就是浏览器和服务器对 url 进行了限制\n主流浏览器：IE OPerate Google 等\n主流服务器：Apache"},"children":[]},{"data":{"id":"d006vbbhxts0","created":1711101530537,"text":"在浏览器的输入栏输入guge.com并按下回车会发生什么","note":"```js\n一：解析 URL，传输协议+主机名+请求资源路径。。。。-> 如果解析出的内容出现一项不合规-->将内容传递给搜索引擎\n                                                                全部合规-->检查非法字符，转移非法字符之后再继续\n```\n\n```js\n二：缓存判断：在浏览器的找到没有失效的缓存-->直接使用（判断浏览器缓存资源有没有过期）\n                  没有缓存或者缓存过期-->向服务器请求（先找本地有没有 域名的IP缓存）\n```\n\n```js\n三：DNS解析：判断浏览器有没有这个域名的IP缓存-->有-->使用\n                                      -->没有-->DNS 服务请求-->DNS 检查自己是否缓存-->无-->根域名服务器发起请求-->顶级域名服务器的地址-->顶级域名服务器发起请求-->权威域名服务器的地址-->权威域名服务器返回IP\n                                                                              -->有-->IP发回给浏览器\n\n DNS解析，客户请求本地DNS属于递归请求，本地DNS请求各级域名服务属于迭代请求\n```\n\n```js\n四：获取MAC地址\n数据传输是需要MAC地址，IP就是用来获取MAC地址的。TCP指定源、目的地址下达->*网络层* 会把本机IP作为源地址、获取到的IP作为目的地址。-->下达到*数据链路层-*->将IP地址与本机子网掩码对比，如果是同一个子网，直接ARP协议广播找MAC--->如果不是同一子网，需要网关转发-->找到目标子网-->ARP 协议广播找MAC（MAC为网关地址）\n```\n\n\n```js\n五：TCP三次握手\n客户端--SNY（建立连接请求）--->服务器\n服务器-----(SNY ACK 确定  并且  建立连接)-->客户端\n客户端--(ACK )--->服务器\n（三次握手完成之后，正式链接）\n```\n\n```js\n九：TCP四次挥手\n客户端---请求释放连接--->服务端\n服务端---收到请求，我检查有没有发完，已发完所有资源---->客户端\n客户端--收到所有资源--->服务端\n服务端--释放连接完成确定---->客户端\n```\n\n```js\n六：HTTPS中会出现TLS四次握手\n客户端------随机数、版本号、可以使用的加密方法--->服务器\n服务器---确认加密方法、TLS证书、随机数---->客户端\n客户端（检查TLS是否有效）----经过TLS 证书公钥加密之后的随机数、加密前面所有内容的 hash 值--->服务端\n服务端（私钥对数据解密）---前面所有内容的 hash 值（对比自己生成的hash值以及解密出来对方的hash值是否一致）---> 客户端\n\n\n四次握手结束，服务端和客户端，约定加密方式对（三个随机数进行加密）-->生成密钥（1、建立了链接，2、并且三个随机数生成了加密的密钥）\n\n```\n\n```js\n七：服务端返回html文件给客户端\n\n```\n\n```js\n八：页面渲染，先构建DOM树和CSSOM树，之后绘制\n```"},"children":[]},{"data":{"id":"d006vocug2g0","created":1711101558917,"text":"对keep-alive的理解","note":"keep-alive 就是 connection：keep-alive\n\nhttp1.0 是没有这个选项的，是短连接，但是可以手动配置 connection：keep-alive，关闭的时候配置需要客户端发送 Connection：close 首部字段。\n\nhttp1.1 默认是长链接，等请求完成之后不会断开 TCP 连接，还会继续等待其他请求。如果需要关闭需要客户端手动配置需要客户端发送 Connection：close 首部字段。\n\n```js\nkeep-alive 的建立和断开\n建立：\n客户端在头部加上connection\n服务端接收到之后修理\n服务端发回connection\n客户端收到，链接成功后，返回给服务端connection\n\n断开：\n分服务端断开\n服务端不返回connection选项，就表示断开。客户端发现没有connection的时候也就断开连接。\n\n\n客户端请求断开：\n客户端发送 connection:close  字段给服务端\n```\n\n```js\nkeep-alive 的缺点\n长期保持TCP链接，导致资源占用，浪费系统资源。\n\nkeep-alive 的优点\n减少了握手的步骤，节省了时间\n```"},"children":[]},{"data":{"id":"d006w0dz4a00","created":1711101585107,"text":"页面多张图片，HTTP是怎样的加载表现","note":"http1 多域名部署：http1 浏览器对一个域名下最大的 TCP 连接数是 6。所以加载多张图片，就需要分成很多次 TCP 连接。\n多域名部署就可以提高同时传输的数量，加快图片获取的速度。\n\nhttp2 多路复用：可以一瞬间加载很多资源\n\n或者精灵图."},"children":[]},{"data":{"id":"d006wcyg5y00","created":1711101612466,"text":"http2的头部压缩算法","note":"http2 头部压缩是 HPACK 算法\n并且 HTTP2 客户端和服务器共同维护一张“首部索引表”\n每当出现一个新的键值对，要么添加要么修改\n可以减低冗余数据，降低开销,节省宽带"},"children":[]},{"data":{"id":"d006wly4wvk0","created":1711101632038,"text":"http的请求报文是什么样的","note":"请求报文有 4 部\n\n- 请求行（请求方法（post、put）+url（/index.html）+协议和协议版本(http/1.1)）\n- 请求头部(max-age user-agent 等键值对)\n- 空行（空格、换行符）\n- 请求体（put post get 上送的请求体）"},"children":[]},{"data":{"id":"d006wqg4luw0","created":1711101641833,"text":"http的响应报文是什么样子的","note":"响应报文有4个部分\n\n- 响应行（协议+协议版本+状态码+状态码原因短语 HTTP/1.1 200 OK）\n- 响应头部 Date content-length content-type\n- 空行\n- 响应体 服务端返回的数据"},"children":[]},{"data":{"id":"d006wy74kpc0","created":1711101658703,"text":"http协议的优点和缺点","note":"HTTP 是超文本传输协议、定义了客户端与服务端之间交换报文的格式和方式，使用 TCP 协议，在传输层进行传输\n优点：\n多端支持：支持客户端、服务端\n小巧：http 协议简单，传输规模小，数据传输简单快速、\n当服务端处理完响应之后，具备断连的条件，会断开 TCP 链接，节约资源\n无状态：每次请求都都是无状态的。不需要先前数据的时候，应答还是非常快的\n灵活：利用 content-type 标记 MIME，可传输任意类型的数据类型\n\n缺点：无状态、不保存客户任何信息，需要借助 cookie 标识\n明文传输：协议报文以明文传输\n不安全：报文被篡改、窃听。不验证通信方信息，可能会遭遇伪装"},"children":[]},{"data":{"id":"d006x4550r40","created":1711101671644,"text":"说一下http3.0","note":"http3 结合 UDP 和 QUIC 协议。多路复用、传输可靠\n1、TLS1.3 减少了原先的握手次数\n2、解决多头堵塞，数据包形成数据流传输，解决了原先的 TCP 对头堵塞问题\n3、快速握手 UDP 可以实现 0-1 个 RTT\n4、QUIC 协议，数据传输可靠性提高，提供数据包重传、拥塞控制的特性"},"children":[]},{"data":{"id":"d006xbk7gaw0","created":1711101687792,"text":"队头堵塞的解决方案"},"children":[]},{"data":{"id":"d006xcirqqg0","created":1711101689882,"text":"url有哪些组成部分"},"children":[]}]},{"data":{"id":"d006lngzcgw0","created":1711100773349,"text":"HTTPS协议"},"children":[{"data":{"id":"d006xo1cmzc0","created":1711101714950,"text":"HTTPS协议"},"children":[]},{"data":{"id":"d006xtbyd7s0","created":1711101726475,"text":"TLS和SSL工作原理"},"children":[]},{"data":{"id":"d006y08i4ww0","created":1711101741504,"text":"数字证书是什么"},"children":[]},{"data":{"id":"d006y3jinsw0","created":1711101748701,"text":"HTTPS通信（握手）过程"},"children":[]},{"data":{"id":"d006yancaiw0","created":1711101764169,"text":"HTTPS的特点"},"children":[]},{"data":{"id":"d006yelw7ew0","created":1711101772789,"text":"HTTPS和如何保证安全"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}