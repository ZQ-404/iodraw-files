{"root":{"data":{"id":"d005x0gbwio0","created":1711098842503,"text":"计算机网络"},"children":[{"data":{"id":"d006l73dxw80","created":1711100737698,"text":"http状态码"},"children":[{"data":{"id":"d006o43e1uo0","created":1711100966260,"text":"常见的状态码","note":"类别以及常见的状态码的含义\n1XX 请求接收到，正在处理\n2XX 请求正常，处理完毕\n3XX 重定向，完成请求，需要客户端附加操作\n4XX 客户端错误，服务器无法处理请求\n5XX 服务端出错\n\n常见状态码\n200 OK 成功\n204 No Content 服务器没有返回响应体\n206 Partial Content 服务器返回指定范围响应实体\n\n301 Moved Permanently （永久性重定向，资源被分配到新的 URI 中，新 URI 会在响应头部 Location 首部字段给出，搜索引擎会更新地址）\n302 Found （临时重定向，资源被临时分配到新的 URI 中，搜索引擎不会更新地址）\n303 See Other （资源在另一个 URI 中，应使用 GET 方法定向获取请求的资源。此时浏览器会把 Post 改成 Get 再发一次（301 302 禁止把 Post 改成 Get，但是实际上大家都是这么做的））\n304 Not Modified （浏览器缓存相关。告诉客户端有缓存，直接使用缓存中的数据）\n307 Temporary Redirect（临时重定向、307 会遵守浏览器标准，不会从 POST 变成 GET。规范要求浏览器继续向 Location 的地址 POST 内容。）\n\n400 Bad Request（请求体中语法错误）\n401 Unauthorized （用户认证失败，没有权限访问）\n403 Forbidden （禁止访问，没有详细说明，IIS 中有定义）\n404 Not Found （服务器上无法找到请求的资源）\n405 Method Not Allowed （服务器不支持改请求方法，客户端可以通过 options 方法预检测）\n\n500 Internal Server Error（服务端执行请求是出错）\n502 Bad Gateway （网关或代理角色的服务器，从上游服务器中接收到的响应是无效的）上游服务器出现问题\n503 Service Unavailable （服务器暂时处于超负载或正在进行停机维护） 服务器超负荷停机\n504 Gateway Timeout （网关或者代理的服务器无法在规定的时间内获得想要的响应） 超时"},"children":[]},{"data":{"id":"d006o7ezig80","created":1711100973492,"text":"重定向状态302、303、307的区别","note":"302 是 http1.0 的协议状态码，在 http1.1 版本的时候为了细化 302 状态码⼜出来了两个 303 和 307。\n303 明确表示客户端应当采⽤ get ⽅法获取资源，他会把 POST 请求变为 GET 请求进⾏重定向。\n307 会遵照浏览器标准，不会从 post 变为 get。"},"children":[]}]},{"data":{"id":"d006lbfp7a80","created":1711100747150,"text":"DNS"},"children":[{"data":{"id":"d006om1nc480","created":1711101005337,"text":"DNS协议是什么","note":"DNS 是域名系统的缩写。就是通过域名查找 IP 地址的系统"},"children":[]},{"data":{"id":"d006orfxv940","created":1711101017085,"text":"DNS同时使用TCP和UDP协议？","note":"DNS 占用 53 端口，同时使用 TCP 和 UDP 协议，分时间使用 TCP 和 UDP 协议\n1、辅域名服务器会定时（一般 3h） 向主域名服务器查询“数据变动”，出现变动辅域名服务器会和主域名服务器进行连接，并数据更新传输，区域传送使用 TCP。\n2、在域名解析的时候使用 UDP 协议，客户端与主服务器直接通讯，使用 UDP 协议（因为本次传输内容小，所以使用 UDP 协议即可）"},"children":[]},{"data":{"id":"d006p23bi140","created":1711101040267,"text":"DNS完整的查询过程","note":"DNS 完整的查询过程\n1、浏览器---------->域名解析器（找缓存、有缓存直接返回）\n2、域名解析器------->本地 DNS 服务（找缓存记录，找到直接返回）\n\n3、本地 DNS 服务-------->.（根域名服务器）\n4、本地 DNS 服务器<------------ . 根域名服务器\n\n5、本地 DNS 服务器----------->com(顶级域名服务器)\n6、本地 DNS 服务器<-----（根域名服务器）-----com(顶级域名服务器)\n\n7、本地 DNS 服务器---------->权威域名服务器\n8、本地 DNS 服务器（缓存）<-------(IP)---权威域名服务器\n\n9、本地 DNS--------IP-->域名解析器\n10、域名解析器-----IP---->浏览器\n\n一小点：上述如果相关域名服务器没有找到 IP，会把上级的域名地址下发给本地的 DNS 服务器"},"children":[]},{"data":{"id":"d006p7grrog0","created":1711101051964,"text":"迭代查询和递归查询","note":"DNS 协议中的迭代查询和递归查询\n递归查询，用户只需要发送一次查询 浏览器到本地 DNS 服务器是递归查询\n迭代查询，用户要发送多次请求 本地 DNS 服务器到三层域名服务器是迭代查询（多次发送请求给三级域名服务器）"},"children":[]},{"data":{"id":"d006pdcpuqw0","created":1711101064780,"text":"DNS记录和报文","note":"DNS 服务器中存储查询记录\n每条资源的记录格式为\n（Name，Value，Type，TTL）\nTTL 资源记录能够被其他的 DNS 服务器缓存多长时间\nype 的值，分别是 A、NS、CNAME 和 MX\n```js\n如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。\n如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。\n如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。\n如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。\n```"},"children":[]}]},{"data":{"id":"d006ld6jie80","created":1711100750950,"text":"网络模型"},"children":[{"data":{"id":"d006pnxvz2w0","created":1711101087828,"text":"OSI七层网络模型","note":"从底倒上分别是：物理层-数据链路层-网络层-传输层-会话层-表示层-应用层\n\n对网络模型各层的解释：\n物理层（010101 传输）\n数据链路层（链路管理） MAC 地址查找\n网络层（IP 选址和路由选择） IP 寻址\n传输层（建立维护端到端的链接） TCP/IP UDP\n会话层（建立维护会话）  \n表示层（数据格式转换、数据加密）\n应用层(为应用提供服务) HTTP，HTTPS，FTP，POP3、SMTP"},"children":[]},{"data":{"id":"d006pt3sw480","created":1711101099069,"text":"TCP/IP五层网络模型","note":"从低向上分别是：物理层--数据链路层（MAC 寻址）--网络层（IP 寻址）--传输层（为两台主机中的进程提供通信服务。）--应用层（http HTTPS）\n\n五层协议每层涉及到的东西：\n应用层（http FTP AMTP） ---传输层（TCP UDP）----网络层（DNS IP ARP 路由器） ---链路层（以太网、网桥 主要 MAC 寻址）"},"children":[]}]},{"data":{"id":"d006lkl3b7s0","created":1711100767067,"text":"TCP和UDP","layout_mind_offset":{"x":-29.99999910593027,"y":113.99999722838402}},"children":[{"data":{"id":"d006q5do5eo0","created":1711101125787,"text":"TCP和UDP的概念和特点","note":"UDP 是面向无连接的，但是会丢包。数据包标注 UDP 之后，直接发送（无连接）\nUDP 支持单播、多播、广播、面向报文、开销小（多对多、一对多、多对一）\nUDP 适用于实时性要求高的场景（实时性）\n\nTCP：面向连接，可靠，阻塞控制，丢包重传、提供全双工通信"},"children":[]},{"data":{"id":"d006qbxr5a00","created":1711101140062,"text":"TCP和UDP的区别","note":"连接对象的个数 TCP 一对一； UDP 可以一对多、一对一、多对一\n传输方式：TCP 是字节流 ；UDP 是报文\n首部开销：TCP 首部开销最小 20 字节；最大 60 字节；UDP 首部开销仅 8 字节"},"children":[]},{"data":{"id":"d006qiu99x40","created":1711101155088,"text":"TCP和UDP的使用场景","note":"TCP：适用于文件传输、登录\nUDP：QQ 聊天、广播通信"},"children":[]},{"data":{"id":"d006qpek6ns0","created":1711101169377,"text":"UDP协议为什么不可靠","note":"UDP 的不可靠性总结：不保证连接、可能会堵塞、可能会丢包、可能会乱序"},"children":[]},{"data":{"id":"d006qtzazqw0","created":1711101179338,"text":"TCP的重传机制","note":"TCP 重传机制：\nTCP 在发送数据之后，会开启定时器，对面没有在指定时间返回正确的 ACK 确认报文，就会重传这段报文，并刷新定时器。\n在达到一定次数还没有成功时放弃并发送一个复位信号。"},"children":[]},{"data":{"id":"d006qy30pm80","created":1711101188270,"text":"TCP的拥塞控制机制","note":"TCP 拥堵机制控制\n慢启动（慢开始）\n拥塞窗口的值（cwnd）慢慢增大。\n慢开始门限值(ssthresh ），在这个值下面就执行慢开始算法，在这个值上面就执行拥塞避免算法。\n\n\n拥塞避免\n在拥堵j只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。\n\n\n快速重传\n快速恢复"},"children":[]},{"data":{"id":"d006r34ltts0","created":1711101199250,"text":"TCP的流量控制机制"},"children":[]},{"data":{"id":"d006r9eqmzs0","created":1711101212923,"text":"TCP的可靠传输机制"},"children":[]},{"data":{"id":"d006rf7fei00","created":1711101225542,"text":"TCP的三次握手四次挥手","note":"TCP 为什么要三次握手？两次不行吗？（找视频看下）\n如果两次握手，就会出现下面这种情况：\n①：第一次客户端把序列号给服务器，第二次服务器给自己的序列号和客户端确定手上的服务器，第三次客户端确定客户端的序列号。如果没有第三次的确定，就很难保证这次请求到底是不是之前丢失的失效请求。\n\n②：第一次请求之后，如果出现卡顿，客户就会进行第二次请求\n等到第二次连接、数据发送完成\n被卡顿的第一次请求出现，与服务端连接，但没有数据，服务端就会一直处于等待状态，会造成资源浪费\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55a81db348584e57abdd01c9555f1d5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n四次挥手\n第一次：客户端数据发送完成之后，会发送 FIN=1 seq=w\n第二次：服务端发送 ，ACK=1 seq=v ack=w+1\n第三次：服务端发送 ，ACK=1 FIN=1 seq=v ack=w+1\n第四次：客户端发送，ACK=1 seq=w+1 ack=v+1\n\n为什么四次挥手？\n因为 TCP 是全双工，必须双方都断开，才算释放连接，否则就属于半释放状态\n另外最后一个次挥手，客户端会处于一段时间的等待状态，这段时间内服务端没重传请求，就表示服务端已经收到 ACK 并断开，这时客户端也会断开\n最后一段时间等待的原因：为了防止第四次挥手的时候出现问题，导致服务器不能正常关闭。\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4190d0d324b427cb63154d3f84e47bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)"},"children":[]},{"data":{"id":"d006rn5w1eo0","created":1711101242863,"text":"TCP粘包是怎么回事，怎么处理","note":"1、为什么会出现粘包：当传输包大于缓冲区的“套接字”的时候，就会被分包；如果小于这个“套接字”的时候，就会出现粘包\n2、怎么去处理粘包？XXXX"},"children":[]},{"data":{"id":"d006rulxnso0","created":1711101259071,"text":"为什么UDP不会粘包","note":"具有保护消息边界，在每个UDP包中就有了消息头。另外当出现超出接收范围的消息时，即使丢失，接受端也不会分两次去接收。两种情况造成不会出现粘包"},"children":[]}]},{"data":{"id":"d006lllclnk0","created":1711100769259,"text":"websocket","layout_mind_offset":{"x":756.9999774396422,"y":905.9999852776532}},"children":[{"data":{"id":"d006s4vrjlc0","created":1711101281433,"text":"对websocket的理解"},"children":[]},{"data":{"id":"d006sbhd1o80","created":1711101295799,"text":"短轮询、长轮询、SSE和websocket的区别"},"children":[]}]},{"data":{"id":"d006lmeqpnk0","created":1711100771036,"text":"HTTP协议"},"children":[{"data":{"id":"d006syrx9pc0","created":1711101346504,"text":"GET和POST的区别","note":"是否缓存：一般 对 Get 进行缓存，post 很少缓存\n安全性：get 如果以 url 形式传递参数的时候，url 会在历史记录中，相对报文传输不安全\n\n应用场景下的区别：Get 主要在幂等操作上，趋向于获取资源，不对资源进行操作。Post 则是趋向于对数据库资源的修改和删除。\n\n报文主体格式：get 报文主体一般为空，post 主体不为空\n\n参数请求长度：url 的长度在浏览器中是有范围的（不同的浏览器范围不同，414 长度超标时，服务器会这样标注），限制了 get 的请求参数\n\n参数数据类型：post 支持更多的数据类型，get 只允许%符号转换之后的编码格式\n"},"children":[]},{"data":{"id":"d006t34lwyg0","created":1711101355978,"text":"POST和PUT的区别","note":"Put 倾向于修改数据\nPost 倾向于创建数据"},"children":[]},{"data":{"id":"d006tfw0q3k0","created":1711101383757,"text":"常见的HTTP请求头和响应头","note":"HTTP Request Header 常见的请求头\nAccept:浏览器能够处理的内容类型\nAccept-Charset:浏览器能够显示的字符集\nAccept-Encoding：浏览器能够处理的压缩编码\nAccept-Language：浏览器当前设置的语言\nConnection：浏览器与服务器之间连接的类型\nCookie：当前页面设置的任何 Cookie\nHost：发出请求的页面所在的域\nReferer：发出请求的页面的 URL\nUser-Agent：浏览器的用户代理字符串\n\n\nHTTP Response Header 常见的响应头\nDate：表示消息发送的时间，时间的描述格式由 rfc822 定义\nserver:服务器名称\nConnection：浏览器与服务器之间连接的类型\nCache-Control：控制 HTTP 缓存\ncontent-type:表示后面的文档属于什么 MIME 类型\n"},"children":[]},{"data":{"id":"d039vww1yx40","created":1711414720692,"text":"常见的content-type","note":"application/x-www-form-urlencoded\napplication/form-data\napplication/josn\ntext/xml"},"children":[]},{"data":{"id":"d006tou9vew0","created":1711101403243,"text":"HTTP状态码304多好、还是少好","note":"对于服务器来说，304 变多，可以减轻他的压力。\n但是对于搜索引擎蜘蛛，当一个网页出现更新停滞时，他的排名就序就会靠后，在搜索引擎蜘蛛这里就显得不友好。\n\n304 变多的原因：\n静态页面、强制静态页面\n页面长期不更新或者更新周期变长\n\n\n304 状态会造成问题\n网站快照停止\n权重下降\n收录减少"},"children":[]},{"data":{"id":"d006txy58h40","created":1711101423068,"text":"常见的HTTP请求方法","note":"get 获取\npost 创建\nput 修改\ndelete 删除\nhead 获取报文首部 ，与 get 相比，不返回主体部分\noptions 询问服务器支持请求的方法，用来跨域请求\nconnect 和代理服务器建立隧道的时候，使用隧道建立 TCP 链接（代理服务器：浏览器和服务器之间的中转站）\ntrace 回显服务器收到的请求，主要测试或诊断"},"children":[]},{"data":{"id":"d006u4idqko0","created":1711101437352,"text":"Options请求方法和使用场景","note":"主要用途有两个：\n获取服务器支持的请求方式；\n检查资源访问权限。CORS 跨域资源共享时 需要判断指定资源的访问权限 （服务端是否设置了 Access-Control-Allow-Origin ）"},"children":[]},{"data":{"id":"d006uszcbzs0","created":1711101490620,"text":"HTTP1.0 和HTTP1.1 的区别","note":"① 连接：http1.0 默认非持久连接； http1.1 默认使用长久连接。\n② 资源请求方面：http1.0 中，每次请求资源的时候，传输的是整个资源对象；http1.1 请求头引入了 range 头域，状态码是 206；便于自由选择，充分利用宽带和连接。\n③ 缓存上面：1.0 缓存机制 if-modified-since expires；1.1 引入了更多了缓存策略 etag 、if-unmodified-since 、if-match 、 if-none-match 对缓存的判断更加准确。\n④http1.1 新增了 host 字段，用来指定服务器域名。但是 1.0 是没有的。1.0 认为一台服务器只有一个 IP 地址，但是随着技术发展，一台物理服务器上会存在多个虚拟机，共用一个 IP。有了 host 就好区分了。\n⑤http1.1 相对 http1.0 新增请求方法如 put head options connect trace"},"children":[]},{"data":{"id":"d006uytb6800","created":1711101503316,"text":"HTTP1.1和HTTP2.0 的区别","note":"①2.0 头信息帧 和数据帧，全是二进制；1.1 头部必须是文本（%符号编码），数据体可以是\n②2.0 多路复用，（一个信道同时传输传输多路信号，即同时传输多条请求和响应），避免队头堵塞\n③ 数据流。响应的时候资源在传输的时候被分成数据包，并且数据包是不按照顺序发送的。这些数据包就叫做一个数据流，每个数据流都有一个独一无二的编号。区分数据包属于哪个数据流\n④ 头信息压缩：头部信息使用 gzip 或 compress 压缩后再发送，节约宽带，降低速度。另外客户端和服务端都维护了一张表，头部信息字段和索引，\n这样下次发请求的时候只需要发送索引号，可提高速度。\n⑤ 服务器推送：http2 在客户端没有请求的情况加可以直接向客户推送“静态资源”。和 WebSocket 以及使用 SSE 数据推送是，不一样的\n⑥ 队头堵塞：队列先进先出，如果队头堵塞的时候耽误了，后面的请求承担不了时间成本就会造成队头堵塞"},"children":[]},{"data":{"id":"d03a7xsizrs0","created":1711415663026,"text":"http与HTTPS的区别","note":"①HTTPS 协议需要 CA 证书，费用高；而 HTTP 协议不需要\n②HTTP 是明文传输，HTTPS 是具有安全性的 ssl 加密传输\n③ 链接方式和默认端口不同 http80 HTTPS 443\n④ HTTP 很简单； HTTPS 是由 SSL 和 HHTP 构建，可以进行加密传输、身份认证。比 http 更加安全\n\n\nHTTP 采用的是明文传输，存在信息篡改、信息窃听、信息劫持\nTSL/SSL 具有身份验证、信息加密、完整性校验的功能，避免 http 的问题"},"children":[]},{"data":{"id":"d006v4nzwvs0","created":1711101516056,"text":"GET方法URL限制的方法","note":"其实 http 并没有对 get 的请求进行限制\n主要就是浏览器和服务器对 url 进行了限制\n主流浏览器：IE OPerate Google 等\n主流服务器：Apache"},"children":[]},{"data":{"id":"d006vbbhxts0","created":1711101530537,"text":"在浏览器的输入栏输入guge.com并按下回车会发生什么","note":"```js\n一：解析 URL，传输协议+主机名+请求资源路径。。。。-> 如果解析出的内容出现一项不合规-->将内容传递给搜索引擎\n                                                                全部合规-->检查非法字符，转移非法字符之后再继续\n```\n\n```js\n二：缓存判断：在浏览器的找到没有失效的缓存-->直接使用（判断浏览器缓存资源有没有过期）\n                  没有缓存或者缓存过期-->向服务器请求（先找本地有没有 域名的IP缓存）\n```\n\n```js\n三：DNS解析：判断浏览器有没有这个域名的IP缓存-->有-->使用\n                                      -->没有-->DNS 服务请求-->DNS 检查自己是否缓存-->无-->根域名服务器发起请求-->顶级域名服务器的地址-->顶级域名服务器发起请求-->权威域名服务器的地址-->权威域名服务器返回IP\n                                                                              -->有-->IP发回给浏览器\n\n DNS解析，客户请求本地DNS属于递归请求，本地DNS请求各级域名服务属于迭代请求\n```\n\n```js\n四：获取MAC地址\n数据传输是需要MAC地址，IP就是用来获取MAC地址的。TCP指定源、目的地址下达->*网络层* 会把本机IP作为源地址、获取到的IP作为目的地址。-->下达到*数据链路层-*->将IP地址与本机子网掩码对比，如果是同一个子网，直接ARP协议广播找MAC--->如果不是同一子网，需要网关转发-->找到目标子网-->ARP 协议广播找MAC（MAC为网关地址）\n```\n\n\n```js\n五：TCP三次握手\n客户端--SNY（建立连接请求）--->服务器\n服务器-----(SNY ACK 确定  并且  建立连接)-->客户端\n客户端--(ACK )--->服务器\n（三次握手完成之后，正式链接）\n```\n\n```js\n九：TCP四次挥手\n客户端---请求释放连接--->服务端\n服务端---收到请求，我检查有没有发完，已发完所有资源---->客户端\n客户端--收到所有资源--->服务端\n服务端--释放连接完成确定---->客户端\n```\n\n```js\n六：HTTPS中会出现TLS四次握手\n客户端------随机数、版本号、可以使用的加密方法--->服务器\n服务器---确认加密方法、TLS证书、随机数---->客户端\n客户端（检查TLS是否有效）----经过TLS 证书公钥加密之后的随机数、加密前面所有内容的 hash 值--->服务端\n服务端（私钥对数据解密）---前面所有内容的 hash 值（对比自己生成的hash值以及解密出来对方的hash值是否一致）---> 客户端\n\n\n四次握手结束，服务端和客户端，约定加密方式对（三个随机数进行加密）-->生成密钥（1、建立了链接，2、并且三个随机数生成了加密的密钥）\n\n```\n\n```js\n七：服务端返回html文件给客户端\n\n```\n\n```js\n八：页面渲染，先构建DOM树和CSSOM树，之后绘制\n```"},"children":[]},{"data":{"id":"d006vocug2g0","created":1711101558917,"text":"对keep-alive的理解","note":"keep-alive 就是 connection：keep-alive\n\nhttp1.0 是没有这个选项的，是短连接，但是可以手动配置 connection：keep-alive，关闭的时候配置需要客户端发送 Connection：close 首部字段。\n\nhttp1.1 默认是长链接，等请求完成之后不会断开 TCP 连接，还会继续等待其他请求。如果需要关闭需要客户端手动配置需要客户端发送 Connection：close 首部字段。\n\n```js\nkeep-alive 的建立和断开\n建立：\n客户端在头部加上connection\n服务端接收到之后修理\n服务端发回connection\n客户端收到，链接成功后，返回给服务端connection\n\n断开：\n分服务端断开\n服务端不返回connection选项，就表示断开。客户端发现没有connection的时候也就断开连接。\n\n\n客户端请求断开：\n客户端发送 connection:close  字段给服务端\n```\n\n```js\nkeep-alive 的缺点\n长期保持TCP链接，导致资源占用，浪费系统资源。\n\nkeep-alive 的优点\n减少了握手的步骤，节省了时间\n```"},"children":[]},{"data":{"id":"d006w0dz4a00","created":1711101585107,"text":"页面多张图片，HTTP是怎样的加载表现","note":"http1 多域名部署：http1 浏览器对一个域名下最大的 TCP 连接数是 6。所以加载多张图片，就需要分成很多次 TCP 连接。\n多域名部署就可以提高同时传输的数量，加快图片获取的速度。\n\nhttp2 多路复用：可以一瞬间加载很多资源\n\n或者精灵图."},"children":[]},{"data":{"id":"d006wcyg5y00","created":1711101612466,"text":"http2的头部压缩算法","note":"http2 头部压缩是 HPACK 算法\n并且 HTTP2 客户端和服务器共同维护一张“首部索引表”\n每当出现一个新的键值对，要么添加要么修改\n可以减低冗余数据，降低开销,节省宽带"},"children":[]},{"data":{"id":"d006wly4wvk0","created":1711101632038,"text":"http的请求报文是什么样的","note":"请求报文有 4 部\n\n- 请求行（请求方法（post、put）+url（/index.html）+协议和协议版本(http/1.1)）\n- 请求头部(max-age user-agent 等键值对)\n- 空行（空格、换行符）\n- 请求体（put post get 上送的请求体）"},"children":[]},{"data":{"id":"d006wqg4luw0","created":1711101641833,"text":"http的响应报文是什么样子的","note":"响应报文有4个部分\n\n- 响应行（协议+协议版本+状态码+状态码原因短语 HTTP/1.1 200 OK）\n- 响应头部 Date content-length content-type\n- 空行\n- 响应体 服务端返回的数据"},"children":[]},{"data":{"id":"d006wy74kpc0","created":1711101658703,"text":"http协议的优点和缺点","note":"HTTP 是超文本传输协议、定义了客户端与服务端之间交换报文的格式和方式，使用 TCP 协议，在传输层进行传输\n优点：\n多端支持：支持客户端、服务端\n小巧：http 协议简单，传输规模小，数据传输简单快速、\n当服务端处理完响应之后，具备断连的条件，会断开 TCP 链接，节约资源\n无状态：每次请求都都是无状态的。不需要先前数据的时候，应答还是非常快的\n灵活：利用 content-type 标记 MIME，可传输任意类型的数据类型\n\n缺点：无状态、不保存客户任何信息，需要借助 cookie 标识\n明文传输：协议报文以明文传输\n不安全：报文被篡改、窃听。不验证通信方信息，可能会遭遇伪装"},"children":[]},{"data":{"id":"d006x4550r40","created":1711101671644,"text":"说一下http3.0","note":"http3 结合 UDP 和 QUIC 协议。多路复用、传输可靠\n1、TLS1.3 减少了原先的握手次数\n2、解决多头堵塞，数据包形成数据流传输，解决了原先的 TCP 对头堵塞问题\n3、快速握手 UDP 可以实现 0-1 个 RTT\n4、QUIC 协议，数据传输可靠性提高，提供数据包重传、拥塞控制的特性"},"children":[]},{"data":{"id":"d006xbk7gaw0","created":1711101687792,"text":"队头堵塞的解决方案","note":"域名分片：多个域名并发，增减并发数量\n并发连接：反正就那意思，用 http3 不就行了，http2"},"children":[]},{"data":{"id":"d006xcirqqg0","created":1711101689882,"text":"url有哪些组成部分","note":"协议部分 http: https: //是分隔符号\n域名部分 www.baidu.com(也可以直接用IP)\n端口部分：:443 (http 默认端口号是 80 HTTPS 默认端口号是 443) 不是必须部分\n虚拟目录：从域名后的第一个“/”开始到最后一个“/”为止 不是必须部分\n文件名称：最后一个“/”开始到“？或者#”为止 （不是必须部分，省略就表示默认文件）\n锚部分：“#”开始到最后，都是锚部分，定位到页面的指定位置\n数部分：从“？”开始到“#”为止之间的部分为参数部分，参数之间用&连接"},"children":[]},{"data":{"id":"d03b2brmuts0","created":1711418044372,"text":"与缓存相关的 HTTP 请求头有哪些","note":"强缓存：\nExpires:过期时间\ncatch-control：（max-age no-cache no-store）\n协商缓存：\nEtag（服务端响应标记，标识码）、If-None-Match（同样的请求，上次的 ETag 请求）\nLast-Modified （最后一次修改）、If-Modified-Since（修改时间）"},"children":[]}]},{"data":{"id":"d006lngzcgw0","created":1711100773349,"text":"HTTPS协议"},"children":[{"data":{"id":"d006xo1cmzc0","created":1711101714950,"text":"HTTPS协议","note":"是一种计算机网络安全通信协议。其实就是经过 http 通信 ，会利用到 SSL、TLS 加密数据包，主要的功能就是保护两端交互数据的完整性和安全性"},"children":[]},{"data":{"id":"d006xtbyd7s0","created":1711101726475,"text":"TLS和SSL工作原理","note":"全称安全传输层协议。是介于“http”和“tcp”之间的一层安全协议，不会影响他两，只是在他们中间多了道操作工序\n\nTSL/SSL 的功能实现主要依赖三类基本算法：散列函数 hash、对称加密、非对称加密。\n这三类算法的主要作用：\n散列函数：验证信息的完整性（hash 值）\n对称加密：通过公钥对数据加解密（TLS 证书）\n非对称加密：实现双方的身份认证、密钥协商（三个随机数）\n\nTSL/SSL\n非对称加密\n\n```js\n客户端共享公钥\n服务器掌握私钥\n客服端发送加密，服务器解密\n```\n\n对称加密\n\n```js\n客户端和服务器共享相同密钥\n不同客户端的 密钥不同\n服务器维护多个密钥\n密钥协商是安全基础\n```\n\n散列算法 hash\n\n```js\n函数不可逆;\n对输入敏感;\n输出入长度固定;\n```\n\n（1）散列函数\n常见的散列函数有 MD5、SHA1、SHA256\n散列函数对输入敏感、输入长度固定，任何数据的修改都会改变散列函数的结果\n所以可以用于防止信息篡改、验证数据的完成性\n\n（2）对称加密\n加密和解密是同一个秘钥，秘钥通过网络传输，会被有心人窃取，对内容进行加解密。一个客户端使用一个秘钥，服务器存储多个秘钥\n常见的对称加密算法有：AES-CBC、DES、3DES 等\n\n（3）非对称加密\n公钥给浏览器、私钥服务端留着。浏览器把数据加密之后传输给服务器，服务器拿私钥进行解密。\n缺点：加密时间会长，每次通信都加密的话，会造成等待时间过长\n\n常见的非对称加密 RSA、ECC、DH。\n特点：加密慢\n\n总结 TSL/SSL\n1、先通过非对称加密进行身份验证、并约定对称加密的秘钥\n2、使用上次约定的加密秘钥，进行数据加密传输\n3、最后散列函数保证信息的完整性"},"children":[]},{"data":{"id":"d006y08i4ww0","created":1711101741504,"text":"数字证书是什么","note":"上述方法并不是绝对安全的。公钥有可能被截获，中间人使用公钥对请求解密，发送另外的响应给浏览器。\n为了解决上述问题，使用 hash 算法对公钥和其他信息进行加密，生成加密信息摘要。\nCA （认证中心）使用自己的私钥对信息摘要加密形成签名。签名和原始数据在一起就叫做数字证书。\n当接收方收到数字证书之后，自己用 hash 算法(对原始数据进行加密）生成摘要。在通过 CA 的公钥解密收到的签名 -》还原成摘要。\n对比两个摘要之后就能确定中间是否被修改。\n\n一般浏览器里会内置一些顶层的认证中心（CA）的证书"},"children":[]},{"data":{"id":"d006y3jinsw0","created":1711101748701,"text":"HTTPS通信（握手）过程","note":"1、客户端------(客户端支持的加密方式、随机数、协议版本号)------>服务器\n2、服务器------(确定加密方式、随机数、服务器证书)----->客户端\n3、客户端（确定证书有效）-----------(证书中公钥加密随机数，提供一个前面所有内容的 hash 的值，用来供服务器检验)---------->服务器\n4、服务器--------（解密随机数、前面所有内容的 hash 值来供客户端检验）---------->客户端\n5、握手成功，服务器和客户端使用前面三个随机数进行数据加密传输。"},"children":[]},{"data":{"id":"d006yancaiw0","created":1711101764169,"text":"HTTPS的特点","note":"优点：\nHTTPS 可以认证用户和服务器，确保数据发送方和接收方的身份；\n加密传输、身份认证、数据完整性，放篡改、窃取、修改\n提高了中间攻击人的成本，安全的\n\n缺点：\nHTTPS 加解密，耗费更多的服务器资源，过程复杂\nHTTPS 协议握手耗费时间，增加页面加载时间\nSSL 证书收费，功能越强大证书费用越高\nHTTPS 链接服务端会占用更多资源， 如果用户数量大的网站，投入成本也就更多\nSSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名"},"children":[]},{"data":{"id":"d006yelw7ew0","created":1711101772789,"text":"HTTPS和如何保证安全","note":"结合对称加密和非对称加密  \n非对称加密，身份验证\nHTTPS 握手，三个随机数生成对称加密的密钥\nCA 证书中心（证书中包含：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的 HASH 算法、证书到期时间），双方数字证书验证防止中间人攻击\n\n通过上述四个要点，极大的提高了中间人攻击的成本，保证了数据传输的安全性"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}