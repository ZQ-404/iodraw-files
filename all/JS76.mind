{"root":{"data":{"id":"cx60x3gezv40","created":1700725627909,"text":"JS"},"children":[{"data":{"id":"cx60xmts1eg0","created":1700725670076,"text":"JS哪些数据类型","note":"1、string number (boolean) null undefined   object bigint (symbol)\n\nsymbol BigInt 是ES6中新增的数据类型\nBigInt表示超出JS最大安全数的\nsymbol表示独一无二且不可变的数据类型，为了解决全局变量出现全局变量冲突的问题\n\n他们还可以分为简单数据类型和复杂数据类型\n简单数据类型存储在栈中、\n复杂数据类型实体存储在堆中、索引地址存储在栈中\n \n\n\n\n\n\n"},"children":[]},{"data":{"id":"cx614wi4rlk0","created":1700726239689,"text":"数据类型检测的方法","note":"1、typeof  二元表达式，简单数据类型准，复杂数据类型object ，函数返回 function。\ntypeof []             // \"object\"\ntypeof function(){}   // \"function\"\n\n\n2、instanceof 三元表达式，复杂数据类型，简单数据类型是false(除非把简单数据类型转换成引用数据类型）\n\n5 instanceof Number // false\n\nnew Number(5) instanceof Number  // true\n\n\n3、constructor   通过构造函数去判断，但是构造函数是可以改变的\ntrue.constructor === Boolean   // true\n\n4、Object.prototype.toString.call（[]） 获得结果为 '[object Array]'\t"},"children":[]},{"data":{"id":"cx61fbg9f400","created":1700727055869,"text":"有哪些判断数组的办法","note":"instansof\nconstructor\nObejct.prototype.toString.call\n\nArray.isArrary()\nobj.__proto__===Array.prototype\nArray.prototype.isPrototypeOf(obj)\n\n"},"children":[]},{"data":{"id":"cx61lw9zsi80","created":1700727571387,"text":"null和undefined的区别","note":"null表示定义，没声明\nundefined表示变量不存在"},"children":[]},{"data":{"id":"cx61muzksjk0","created":1700727646945,"text":"typeof null 的结果是什么","note":"object  \n这是一个历史遗留问题，因为null机械解析码和object 一样。"},"children":[]},{"data":{"id":"cx61pmq7qzc0","created":1700727864057,"text":"instanceof 实现的原理 以及实现","note":"instanceof  主要通过__proto__不断地访问上层原型链，去判断数据类型的。\n\nmyInstatnce(left,right){\nlet proto=Object.getPrototypeOf(left);\n    let prototype=right.prototype;\n    while(true){\n    \n if(proto===prototype) return true;\n    if(!proto) return false;\n    proto=Object.getPrototypeOf(proto);\n    \n    \t\n    }\n    \n}"},"children":[]},{"data":{"id":"cx61zg8c59c0","created":1700728633557,"text":"0.1+0.2 为什么不等于0.3 怎么让他们相等","note":"1、0.1  0.2解析成二进制之后都是无限循环的数\n\nJS有个机械精确度 Number.EPSILON小于等于这个值，就表示在精确范围内\n\n\n怎么让他们相等 \nisEquit（num1，num2，sum）{\nreturn num1+num2-sum<Number.EPSILON\n}"},"children":[]},{"data":{"id":"cx627jmevfc0","created":1700729267852,"text":"如何安全的获取undefined","note":"使用void 0\nundefined它其实是一个「全局对象」中的一个「属性」，\nwindow.undefined 可以获取到这个值，说明他在ES里面不是一个保留字，直接使用不安全，有可能获取的是一个变量。"},"children":[]},{"data":{"id":"cx629tw6wm80","created":1700729446939,"text":"typeof NaN","note":"number"},"children":[]},{"data":{"id":"cx62j0nd4fs0","created":1700730166920,"text":"isNaN 和 number.isNaN 的区别","note":"isNaN 是ES5 中的方法，会对传入的参数进行隐式转换，再去判断\n\nnumber.isNAN 不会对传入的参数进行隐式转换，会直接判断是不是NAN  如下所示（或者是一个公式计算完成之后是NaN）\n\nNumber.isNaN(NaN); // true\nNumber.isNaN(Number.NaN); // true\nNumber.isNaN(0 / 0); // true\nNumber.isNaN(37); // false\n\n所以number.isNaN 更加准确一点\n\nisNaN('NaN')\ntrue\nNumber.isNaN('NaN')\nfalse"},"children":[]},{"data":{"id":"cx62lnzj3xc0","created":1700730374450,"text":"其他值转换成字符串的规则","note":"null 'null'\nundefined  'undefined'\nnumber  '值'\nobject  '[object object]'\nbigint '值'\nsymbol  '值'\nboolean 'true' 'false'\n\n"},"children":[]},{"data":{"id":"cx62r1a1cds0","created":1700730795205,"text":"其他值转换成数值","note":"null 0\nundefined NaN\nstring  数字或者NaN\nObject  先转换成基础数据类型，再转换成数值\nbigint 就是数字\nsymbol  报错\nboolean false 0   true 1"},"children":[]},{"data":{"id":"cxfdzgmm4ag0","created":1701676527349,"text":"其他值到布尔值的转换","note":"undefined 、null、 “”、0、NAN 会被转换成false\n\n除去上面这些，会被转换成true"},"children":[]},{"data":{"id":"cxfe5cnhgrk0","created":1701676988880,"text":"||和&&的返回值","note":"|| 如果第一个值是true 则返回第一个值，如果第一个人值是false 则返回第二个值\n\n&&第一个值是true则返回第二个值，如果第一个是false，则返回第一个值\n\n\n"},"children":[]},{"data":{"id":"cxfe81inl680","created":1701677199736,"text":"Object.is() 以及操作符===   == 的区别","note":"Object.is 和 === 他们两的转换结果是相反的，所以就记住Object.is(+0,-0)是false即可。\nObject.is(+0,-0);  得到的结果是false\nObject.is(NaN,NaN); true\n\n-0 === +0   ;得到的结果是true\nNaN===NaN  ; 得到的结果是false\n\n\n\n"},"children":[]},{"data":{"id":"cxfeapobrs00","created":1701677409050,"text":"什么是JS的包装类型","note":"基本数据类型没有属性和方法，为了方便操作基础类型的值，调用基础类型的属性和方法的时候JS会将基础类型转换成包装类型\n\n''.length  ''.toUpperCase()\n\nObject('');  可以将基础数据转换成包装数据类型\n\nString（''）\n\n''.valueOf() 可以获取到数据的基础类型"},"children":[]},{"data":{"id":"cxfelabwh000","created":1701678237652,"text":"JS 中如何进行隐式转换的","note":"ToPrimitive(obj,type);\n如果是type是string \n先toString() 转换成基础数据类型，则返回，否则valueOf步骤同上，报错则typeError；\n\n如果type是number  先valueOf() ,然后再String（）；报错则typeerror；\n\n\n注意事项：\n不传值的情况，如果对象为 Date 对象，则type默认为string；其他情况下，type默认为number，使用valueOf()。\n\n"},"children":[]},{"data":{"id":"cxfev1pb2000","created":1701679002514,"text":"+什么时候拼接、什么时候是计算","layout_mind_offset":{"x":-32,"y":0},"note":"+当旁边有字符的时候就是拼接。BigInt提出之前超出范围的数字表达不出来，需要借助第三方，bigInt 就是为了解决这个问题。"},"children":[]},{"data":{"id":"cxfexutsifk0","created":1701679222640,"text":"Object.assign 和 扩展运算符 是浅拷贝还是深拷贝","note":"Object.assign()  第一层是深拷贝的效果，第二层是浅拷贝的效果。\nObject.assign({},Obj)\n\n\n扩展运算符就是浅拷贝。{...Obj}"},"children":[]},{"data":{"id":"cxff061d6xc0","created":1701679403771,"text":"let const var 的区别","note":"var 变量提升  可以重复声明。\n\nconst   ！必须初始值设置、！变量指针不改变、 变量不提升 暂时性死区 块级作用域  不可以重复声明。（const 指向的变量地址不发生改变，其值是改变的）\n\nlet  变量不提升  块级作用域  暂时性死区 不可以重复声明。\n\n\n\n\n\n"},"children":[]},{"data":{"id":"cxff7k9udeo0","created":1701679983307,"text":"new 一个箭头函数会怎么样","note":"创建一个空对象\n\n将空对象的proto指向go"},"children":[]},{"data":{"id":"cxffad04tlc0","created":1701680202575,"text":"箭头函数和普通函数的区别","note":"写法更加简洁\n没有自己的this\n箭头函数继承的this指向不改变\n不能通过call apply  bind 改变this的指向\n\n箭头函数不能作为构造函数使用\n\n箭头函数没有自己的arguments\n\n箭头函数没有prototype\n\n箭头函数不能用Generator 不能使用yeild关键字\n\n箭头函数的this不是本身，是捕获的箭头函数所在当前位置上下文的this"},"children":[]},{"data":{"id":"cxffl12xn7k0","created":1701681038629,"text":"map 和 weakmap和object的区别","note":"map 的键可以是任意类型，object的键只能是string；\n！！ map是可迭代的，object不可迭代；\nmap是通过.size 直接访问到键值的个数，object不行；\nmap频繁的删除新增键值性能优良，object不行；\n！！ 意外建 object里面有意外建，map没有；\n！！ map是有序的，object是无序的；\n\nweakmap 的区别 \nweakmap的键类型必须是对象，但也不能是null。注意事项：被weakmap键所指的对象，不计入垃圾回收机制。"},"children":[]},{"data":{"id":"cxgu3cv5w680","created":1701823530331,"text":"JS脚本延迟加载的方式","note":"1、defer 异步加载 解析   等到页面完全解析 之后开始执行脚本  不打断\n2、async  异步加载 解析  等到加载完成会执行，并打断页面其他进程\n3、JS脚本放在最后加载\n4、settimeout 延迟加载JS脚本\n5、动态创建DOM，监听文档加载事件，加载完成"},"children":[]},{"data":{"id":"cxgubqtvovk0","created":1701824187642,"text":"JS 类数组对象的定义 ","note":"类数组就是 函数参数这种形似数组，但是不能调用数组API的。\n\nArray.form(arrayLike)\n\nArray. .cancat.apply([],arrayLike)\n\nArray.prototype.slice.call()\n\nArray.prototype.splice.call()\n\n\n怎么遍历类数组？\n1、转换成数组\n2、Array.prototype.foreach.call(arrayLike,()=>{})\n\n"},"children":[]},{"data":{"id":"cxguohotyv40","created":1701825186479,"text":"数组有哪些原生方法","note":"push pop  尾添加  尾删除\nshift  unshift   首删除  首添加\n\nconcat 返回拼接好的数组\n\nslice   数组截取，不影响原数组\n\nsplice  数组插入的方法 \nindexOf  lastIndexOf\n\nevery some  filter map  foreach\n\nreduce  reduceright  数组归并的方法\n\n\n\n\n"},"children":[]},{"data":{"id":"cxgv60by7tc0","created":1701826559250,"text":"什么是DOM ？什么是BOM？","note":"DOM指的是文档对象模型。\nBOM是浏览器对象模型：\nwindow 对象含有 location 对象、navigator 对象、screen 对象等子对象\n\n\n"},"children":[]},{"data":{"id":"cxgvb982qh40","created":1701826970428,"text":"AJAX的理解？怎么创建一个AJAX？","note":"ajax是异步通信，局部更新页面的一种技术。\n下面是xhr的创建\n\nconst SERVER_URL = \"/server\";\nlet xhr = new XMLHttpRequest();\n// 创建 Http 请求\nxhr.open(\"GET\", url, true);\n// 设置状态监听函数\nxhr.onreadystatechange = function() {\n  if (this.readyState !== 4) return;\n  // 当请求成功时\n  if (this.status === 200) {\n    handle(this.response);\n  } else {\n    console.error(this.statusText);\n  }\n};\n// 设置请求失败时的监听函数\nxhr.onerror = function() {\n  console.error(this.statusText);\n};\n// 设置请求头信息\nxhr.responseType = \"json\";\nxhr.setRequestHeader(\"Accept\", \"application/json\");\n// 发送 Http 请求\nxhr.send(null);\n"},"children":[]},{"data":{"id":"cxgvmvisqy80","created":1701827880971,"text":"ES6模块 和commonJS 模块的区别 ","note":"一、语法不同 ：\nmodule.export require('') commonJS 写法；\n\nimport() form '' export ES6module 写法\n二、导入方式\ncommonJS 是对值的拷贝，改变模块，导入的值不改变。 \nES6 是对值的引用，改变模块，导入的值改变。\n\n 三、模块加载时间不相同\n ES6 是编译时加载， commonJS 是运行时加载。\n \n 四、缓存机制\n CommonJS 里面有缓存机制，一次请求之后，文件不变化就不发第二次（nodeJs 模块管理）\n"},"children":[]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}