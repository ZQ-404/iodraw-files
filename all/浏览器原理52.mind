{"root":{"data":{"id":"czsdwlfixrc0","created":1710308899029,"text":"浏览器原理"},"children":[{"data":{"id":"czsisb5wxao0","created":1710322668773,"text":"浏览器安全"},"children":[{"data":{"id":"czsism059yg0","created":1710322692369,"text":"什么是XSS","note":"XSS解释：\n跨站脚本攻击（代码注入，浏览器没有办法过滤，执行了恶意代码）。\n\n恶意代码可能会造成的问题：\n1、获取缓存的数据，如DOM、cookie、localStorage；\n2、DOS攻击，发送请求，占用服务器资源，从而使用户无法访问服务器；\n3、破坏页面结构；\n4、流量劫持（将链接指向某网站）；\n\nXSS攻击方式有三种：\n1、存储型（恶意脚本会存储在目标服务器上，浏览器请求回来之后，执行恶意脚本）\n2、反射型（诱导用户访问一个带有恶意代码的 URL 。目标服务器那边把带有恶意代码的数据发送到浏览器端）\n3、DOM节点型（修改页面的 DOM 节点形成的 XSS）\n\n三者的区别：\n反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。\nDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。\n"},"children":[]},{"data":{"id":"czsisw86c340","created":1710322714622,"text":"如何防御XSS","note":"浏览器这边的处理：\n1、纯前端的方式，不用服务器端拼接返回（不使用服务端渲染）。\n2、对需要插入到 HTML 中的代码做好充分的转义，数据获取渲染和字符串拼接的时候判断预防恶意代码。\n\n借助CSP（内容安全策略）：\n本质：\n建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。\n配置规则的方式有两种：\n一种是设置 HTTP 首部中的 Content-Security-Policy。\n一种是设置 meta 标签的方式。\n\n一些敏感信息进行保护：\n比如 cookie 使用 http-only，使得脚本无法获取。\n使用验证码，避免脚本伪装成用户执行一些操作。\n"},"children":[]},{"data":{"id":"czsit3dwdfk0","created":1710322730206,"text":"什么是CSRF","note":"CSRF 攻击指的是跨站请求伪造攻击。\n本质：\n利用 cookie 会在同源请求中携带发送给服务器的特点，冒充用户去发送攻击请求给到第三方。（只能利用 cookie，但是不能访问获取 cookie ）\n\n攻击类型：\nGET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。\nPOST 类型的 CSRF 攻击，比如构建一个隐藏的表单，当用户进入页面时，自动提交这个表单。\n链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，诱导用户去点击。"},"children":[]},{"data":{"id":"czsitz58zw00","created":1710322799340,"text":"怎么去防御CSRF","note":"进行同源检测：http 请求头中 origin 或者 referer 字段来判断是否同源，从而过滤出恶意网站。\n缺点：referer可以被伪造。可以伪造成搜索引擎的链接。搜索引擎链接屏蔽也不好，不屏蔽也不好。\n\n使用 CSRF Token 进行验证:\n服务器向用户返回一个随机数 Token，用户再次发起请求时，在请求参数中需要加token。\n缺点：\n所有请求都添加上这个 token，操作比较繁琐。\n如果超出负载，求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证。\n\n对 Cookie 进行双重验证：\n利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。\n用户第一次访问服务器，向请求域名注入一个Cookie。用户再次请求需要将Cookie\t拼接到URL参数中。\n方便并且不涉及到分布式访问的问题。\n缺点：\nXSS漏洞的时候失效。\n不能做到子域名的隔离。\n\n\n"},"children":[]},{"data":{"id":"czsiu6vkva80","created":1710322816169,"text":"什么是中间人攻击，如何防御中间人攻击","note":"在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。\n\n攻击的流程：\n用户发送握手请求，中间人截获。\n服务器发送公钥，中间人拦截，保留。伪造公钥发送给中间人。\n用户拿到伪造密钥，⽣成加密hash值发给服务器。中间人拦截，用自己得私钥解密。伪造恶意请求，使用保留的公钥加密发送。\n服务器解密之后，发送加密数据给客户端。"},"children":[]},{"data":{"id":"czsiulqzh800","created":1710322848543,"text":"有哪些可能会影响前端安全的问题","note":"iframe的滥⽤\n跨站脚本 XSS\n跨站伪造请求 CSRF\n恶意第三⽅库"},"children":[]},{"data":{"id":"czsiv073xdk0","created":1710322879993,"text":"网络劫持有哪几种，如何防范","note":"⽹络劫持分为两种:\n（1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)\nDNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器\n302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容\n\n（2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)\n\nDNS劫持由于涉嫌违法，已经被监管起来。预防HTTP劫持的好方法，就是明文改成加密传输。"},"children":[]}]},{"data":{"id":"czsivr9vutc0","created":1710322938934,"text":"进程与线程"},"children":[{"data":{"id":"czsiw1r6xqg0","created":1710322961748,"text":"进程与线程的概念","note":"进程：是指 CPU 在运行指令、加载和保存上下文所需的时间。\n\n线程：是进程中的更小单位，描述了执行一段指令所需的时间。\n\n进程是资源分配的最小单位，线程是CPU调度的最小单位。\n\n特点：\n进程之间相互隔离，一个进程崩溃了，不影响其他进程。\n任意一个线程出现问题，导致整个进程崩溃。\n线程之间共享进程中的数据。\n进程关闭之后，操作系统会回收进程占用的内存。\n\n1个浏览器主进程：负责界面显示、用户交互、子进程管理，同时提供存储等功能。\n多个渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页。\n多个插件进程：主要是负责插件的运行。\n一个网络进程：主要负责页面的网络资源加载。\n一个GPU进程:绘制UI 界面、 3D CSS 的效果。\n\n所以打开一个网页，至少需要四个进程\n\n浏览器使用多进程模式的优点和缺点\n优点：稳定，不容易崩掉\n缺点：占用更多的资源"},"children":[]},{"data":{"id":"czsiwamx3p40","created":1710322981081,"text":"进程与线程的区别","note":"1、进程是CPU资源分配的最小单位，线程是CPU调度的最小单位；\n2、进程可以看做独立的应用，线程不能；\n3、线程通信需要共享一个进程，而进程之间需要通过进程通讯机制；\n"},"children":[]},{"data":{"id":"czsiwjjszi80","created":1710323000484,"text":"浏览器渲染进程的线程有哪些","note":"浏览器渲染进程的线程有五种：\n1、GUI渲染线程：解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面。（重绘、重构的时候会触发这个线程）\n2、JS引擎线程：解析Javascript脚本，运行代码。一个Tab页只有一个JS引擎线程。\n3、时间触发线程 时间触发线程：控制事件循环。事件被触发时，该线程会把事件添加到待处理队列的队尾。（如setTimeOut）\n\n4、定时器触发进程 定时器触发进程：即setInterval与setTimeout所在线程。定时器在指定时间点将任务添加到事件队列中。\n\n5、异步http请求线程：XMLHttpRequest连接后新开一个线程请求。检测到状态变更时，将回调函数放入事件队列中，等待JS引擎空闲后执行。\n\n"},"children":[]},{"data":{"id":"czsix54752g0","created":1710323047429,"text":"进程之间的通信方式","note":"1、管道通信：管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。（单向通讯、生命周期随进程、有血缘关系的进程进行通讯、面向字节流、依赖于文件系统）\n2、消息队列通信：消息队列就是一个消息的列表。\n3、信号量通信：\n4、信号通信：\n5、共享内存通信：\n6、套接字通信：\n\n（不信会问这么细）"},"children":[]},{"data":{"id":"czsixcpeprs0","created":1710323063949,"text":"僵尸进程和孤儿进程是什么","note":"僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源。\n孤儿进程：父进程退出了，一个或多个进程还在运行。孤儿进程将被init进程收养，并由init进程对它们完成状态收集。"},"children":[]},{"data":{"id":"czsixshoaeg0","created":1710323098310,"text":"死锁产生的原因，怎么去解决死锁的问题","note":"死锁：\n多个进程在运行过程中因争夺资源而造成的一种僵局，无外力作用，它们无法再向前推进。\n\n产生死锁的原因：\n竞争不可剥夺资源、竞争临时资源。\n进程间推进顺序非法。\n\n预防死锁的方法：\n资源一次性分配。\n只要有一个资源得不到分配。\n资源有序分配法。"},"children":[]},{"data":{"id":"czsiz1gktq80","created":1710323196199,"text":"如何实现浏览器多标签之间的通讯","note":"使用 websocket 协议： websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。\n\n使用 ShareWorker 的方式：这个时候共享线程就可以充当中介者的角色。\n\n使用 localStorage 的方式：可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。\n\n使用 postMessage 方法：能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。\n"},"children":[]},{"data":{"id":"czsizd2ouu00","created":1710323221481,"text":"对service worker的理解","note":"运行在浏览器背后的独立线程，一般可以用来实现缓存功能。\n传输协议必须为 HTTPS。\n\n三个步骤：首先需要先注册 Service Worker，\n然后监听到 install 事件以后就可以缓存需要的文件，\n下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。\n\n// index.js\nif (navigator.serviceWorker) {\n  navigator.serviceWorker\n    .register('sw.js')\n    .then(function(registration) {\n      console.log('service worker 注册成功')\n    })\n    .catch(function(err) {\n      console.log('servcie worker 注册失败')\n    })\n}\n// sw.js\n// 监听 `install` 事件，回调中缓存所需文件\nself.addEventListener('install', e => {\n  e.waitUntil(\n    caches.open('my-cache').then(function(cache) {\n      return cache.addAll(['./index.html', './index.js'])\n    })\n  )\n})\n// 拦截所有请求事件\n// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据\nself.addEventListener('fetch', e => {\n  e.respondWith(\n    caches.match(e.request).then(function(response) {\n      if (response) {\n        return response\n      }\n      console.log('fetch source')\n    })\n  )\n})\n"},"children":[]}]},{"data":{"id":"czsizzpzz880","created":1710323270779,"text":"浏览器缓存"},"children":[{"data":{"id":"czsj08kqmc00","created":1710323290052,"text":"对浏览器缓存机制的理解","note":"1、浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用。\n\n2、强制缓存优先级较高。下一次加载资源时，Http1.1如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存。http1.0使用 expires 头判断是否过期。\n\n3、强制缓存没有被命中，则开始协商缓存。向服务器发送带有 If-None-Match（Etag） 和 If-Modified-Since(Last-modified) 的请求。\n\n4、服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；不一致则有改动，返回新的资源文件带上新的 Etag 值并返回 200。\n\n5、服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；\n6、"},"children":[]},{"data":{"id":"czsj0j2r3hc0","created":1710323312909,"text":"浏览器缓存资源的位置有哪些"},"children":[]},{"data":{"id":"czsj0q37xhs0","created":1710323328175,"text":"强缓存与协商缓存的区别","note":"强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。\n\n其中一种方式就可，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。\n\nExpires 是一个绝对时间，它是服务器的时间，因此客户端的时间和服务器端的时间不一致,或者用户对客户端时间进行修改，会影响强缓存命中的结果。\n\n在 HTTP 1.1 提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值：\npublic：资源表示可以被任何对象缓存。\nprivate：该字段值的资源只能被用户浏览器缓存。\nno-cache：需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；\nno-store:设置了该字段表示禁止任何缓存，每次发起新的请求，拉取最新的资源；\nmax-age=  :设置缓存的最大有效期，单位为秒；\ns-maxage=: 优先级高于max-age或者Expires头,但是仅适用于共享缓存(CDN)，；\nmax-stale[=]：表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。\n\n命中协商缓存的条件有两个：max-age=xxx 过期了、值为no-store。（命中缓存的意思就是需要重新请求资源的意思）\n\n没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。\n\n http 响应头信息中的Etag（服务器返回） 和Last-Modified（服务器返回）属性。\n \n http请求头If-None-Match（上次接收的Etag），If-modified-Sinc（上次接收的last-Modified）。\n \n 当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。\n \n 使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致。\n \n\n"},"children":[]},{"data":{"id":"czsj10kcraw0","created":1710323350979,"text":"为什么需要浏览器缓存","note":"浏览器的缓存，主要针对的是前端的静态资源。\n\n服务器静态资源没有更新就不拉取使用浏览器缓存资源，更新就拉取最新的。\n\n减少请求次数，提高网站性能。"},"children":[]},{"data":{"id":"czsj200syt40","created":1710323428161,"text":"点击刷新按钮、F5、Ctrl+F5、地址栏回车 有什么区别","note":"刷新按钮或者按 F5： 会带上If-Modifed-Since，If-None-Match，服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。\n\n用户按 Ctrl+F5（强制刷新）：浏览器不仅会对本地文件过期，不带 If-Modifed-Since，If-None-Match请求，返回结果是 200。"},"children":[]}]},{"data":{"id":"czsj2y38tg80","created":1710323502319,"text":"浏览器组成"},"children":[{"data":{"id":"czsj39yyrjc0","created":1710323528182,"text":"对浏览器的理解","note":"浏览器的主要功能是将用户选择的 web 资源呈现出来。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。\n\n浏览器可以分为两部分，shell 和 内核。\n\n\nshell 是指浏览器的外壳：例如菜单，工具栏，界面操作，参数设置等。\n内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。"},"children":[]},{"data":{"id":"czsj3eub5eo0","created":1710323538784,"text":"对浏览器内核的理解","note":"内核主要分成两部分：\n渲染引擎：渲染引擎可以显示 html、xml 文档及图片，借助插件显示 PDF 格式。\nJS 引擎：解析和执行 javascript 来实现网页的动态效果。"},"children":[]},{"data":{"id":"czsj3mh05480","created":1710323555394,"text":"常见的浏览器内核比较","note":"比较就先省略吧。\nTrident： IE 浏览器用的内核。\n\nGecko：Firefox 和 Flock 所采用的内核。\n\nPresto：Opera 曾经采用的就是 Presto 内核，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。\n\nWebkit：Webkit 是 Safari 采用的内核。\n\nBlink：谷歌浏览器采用的内核。"},"children":[]},{"data":{"id":"czsj3scl9pk0","created":1710323568188,"text":"常见浏览器所用的内核","note":"Trident： IE 浏览器用的内核。\n\nGecko：Firefox 和 Flock 所采用的内核。\n\nPresto：Opera 曾经采用的就是 Presto 内核，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。\n\nWebkit：Webkit 是 Safari 采用的内核。\n\nBlink：谷歌浏览器采用的内核。"},"children":[]},{"data":{"id":"czsj3yyyn3k0","created":1710323582601,"text":"浏览器主要的组成成分","note":"⽤户界⾯：地址栏、前进/后退按钮、书签菜单等\n\n浏览器引擎 ：在⽤户界⾯和呈现引擎之间传送指令。\n\n呈现引擎：如果请求的内容是 HTML，负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n\n⽹络 ：⽹络调⽤，⽐如 HTTP 请求。\n\n⽤户界⾯后端：于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。\n\nJavaScript 解释器：解析和执⾏ JavaScript 代码。\n\n数据存储：持久层。浏览器需要在硬盘上保存各种数据。"},"children":[]}]},{"data":{"id":"czsj2w9qgkg0","created":1710323498358,"text":"浏览器渲染原理","layout_mind_offset":{"x":1.1368683772161603e-13,"y":-14}},"children":[{"data":{"id":"czsj4c0wz2g0","created":1710323611017,"text":"浏览器渲染过程"},"children":[]},{"data":{"id":"czsj4hy0pjc0","created":1710323623903,"text":"浏览器渲染优化"},"children":[]},{"data":{"id":"czsj4m7p97k0","created":1710323633195,"text":"渲染的过程中遇到JS文件如何处理"},"children":[]},{"data":{"id":"czsj4wpfrls0","created":1710323656036,"text":"什么是文档的预解析"},"children":[]},{"data":{"id":"czsj56adtcw0","created":1710323676893,"text":"CSS是如何阻挡文件解析的"},"children":[]},{"data":{"id":"czsj5fv7m9c0","created":1710323697744,"text":"如何优化关键渲染路径"},"children":[]},{"data":{"id":"czsj5vhzqjk0","created":1710323731773,"text":"什么情况阻塞渲染"},"children":[]}]},{"data":{"id":"czsizxhxwdk0","created":1710323265938,"text":"浏览器本地存储"},"children":[{"data":{"id":"czsj6o5lvrk0","created":1710323794151,"text":"浏览器本地存储的方式和使用场景","note":"Cookie\n为服务端判断两个请求是否是同一用户发起的。\nCookie的大小只有4kb，是一种纯文本文件，每次发起HTTP请求都会携带Cookie。\n\nCookie是无法跨域名的；Cookie一旦创建成功，名称就无法修改；每个域名下Cookie的数量不能超过20个；cookie可以被转发存在安全问题；Cookie在请求一个新的页面的时候都会被发送过去。\n\n跨域共享Cookie两种方法：\n1、使用Nginx反向代理。\n2、在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId。\n\nLocalStorage\nLocalStorage是HTML5新引入的特性，存储的信息较大。\n\n优点：\n大小一般为5MB。\nLocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理。\n仅储存在本地，不像Cookie那样每次HTTP请求都会被携带。\n\n缺点：\nIE8以下版本的浏览器不支持。\n浏览器设置为隐私模式，无法读取到LocalStorage。\nLocalStorage受到同源策略的限制。\n\nSessionStorage\nSessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。\n\nSessionStorage和LocalStorage对比：\nSessionStorage和LocalStorage都在本地进行数据存储；\n\nSessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage只有在同一浏览器的同一窗口下才能够共享；\nLocalStorage和SessionStorage都不能被爬虫爬取；\n\n使用场景：\nSessionStorage具有时效性，可以存储一些游客登录信息。\n换肤的信息存储在本地的LocalStorage中，用户浏览信息也会存储在LocalStorage中。\n\n"},"children":[]},{"data":{"id":"czsj6yiicls0","created":1710323816699,"text":"cookie有哪些字段，作用分别是什么","note":"Name：cookie的名称\nValue：cookie的值，\nsize： cookie的大小\nPath：可以访问此cookie的页面路径。path是/test。\nDomain：可以访问该cookie的域名.abc.com。\nHTTP： 该字段包含HTTPOnly 属性 ，规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。\nExpires/Max-size ： 此cookie的超时时间。"},"children":[]},{"data":{"id":"czsj7idwtb40","created":1710323859956,"text":"cookie、localStorage、sessionStorage的区别","note":"cookie：服务器端用于记录用户状态的一种方式。\nsessionStorage：只能被同一个窗口的同源页面所访问共享。\nlocalStorage：它一般也能够存储 5M 或者更大的数据，除非手动删除它，否则它不会失效。\n\n\n本地存储大量数据的时候使用 indexDB ， indexDB 的一种本地的数据库存储机制。\n"},"children":[]},{"data":{"id":"czsj7twulfk0","created":1710323885046,"text":"前端存储方式有哪些","note":"cookies：个domain限制20个cookie，⼤⼩只有4k。\nlocalStorage：永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ 。\nsessionStorage：同源窗⼝中共享，当⻚⾯关闭后会被清理。\nWeb SQL：真正意义上的关系型数据库，但是2010年被W3C废弃的本地数据库数据存储⽅案。\nIndexedDB： HTML5标准的数据库储存⽅。"},"children":[]},{"data":{"id":"czsj80lwqdk0","created":1710323899622,"text":"indexedDB有哪些特点","note":"键值对储存：\n异步：IndexedDB 操作时用户依然可以进行其他操作，这与 LocalStorage 形成对比，\n支持事务：IndexedDB 支持事务\n同源限制：网页只能访问自身域名下的数据库，而不能访问跨域的数据库。\n储存空间大：IndexedDB 的储存空间不少于 250MB，甚至没有上限。\n支持二进制储存：储存二进制数据（ArrayBuffer 对象和 Blob 对象）。"},"children":[]}]},{"data":{"id":"czsivood4zs0","created":1710322933279,"text":"浏览器同源策略"},"children":[{"data":{"id":"czsj955b3gw0","created":1710323987866,"text":"什么是同源策略"},"children":[]},{"data":{"id":"czsj9923ln40","created":1710323996379,"text":"如何解决跨域问题"},"children":[]},{"data":{"id":"czsj9hftc340","created":1710324014623,"text":"正向代理和反向代理的区别"},"children":[]},{"data":{"id":"czsj9swjbq80","created":1710324039579,"text":"Nginx的概念以及他的工作原理"},"children":[]}]},{"data":{"id":"czsjakct5z40","created":1710324099336,"text":"浏览器事件机制"},"children":[{"data":{"id":"czsjatz64ug0","created":1710324120279,"text":"事件是什么？事件模型？"},"children":[]},{"data":{"id":"czsjb08si940","created":1710324133921,"text":"如何阻止事件冒泡"},"children":[]},{"data":{"id":"czsjb65mw400","created":1710324146791,"text":"对事件委托的理解"},"children":[]},{"data":{"id":"czsjbaoi8200","created":1710324156639,"text":"事件委托的理解"},"children":[]},{"data":{"id":"czsjbj6lfgg0","created":1710324175147,"text":"事件委托的使用场景"},"children":[]},{"data":{"id":"czsjbpm9d000","created":1710324189155,"text":"同步和异步的区别"},"children":[]},{"data":{"id":"czsjbu45wbc0","created":1710324198945,"text":"对事件循环的理解"},"children":[]},{"data":{"id":"czsjc2q7hy00","created":1710324217692,"text":"宏任务和微任务分别有哪些"},"children":[]},{"data":{"id":"czsjcc8gfrs0","created":1710324238387,"text":"什么是执行栈"},"children":[]},{"data":{"id":"czsjcnh1rug0","created":1710324262851,"text":"Node中的eventLoop和浏览器中的有什么区别？process.nexttick的执行顺序"},"children":[]},{"data":{"id":"czsjdakakyo0","created":1710324313113,"text":"事件触发的顺序是怎样的"},"children":[]}]},{"data":{"id":"czsjdixwn2w0","created":1710324331350,"text":"垃圾回收机制"},"children":[{"data":{"id":"czsjdoqw53s0","created":1710324343987,"text":"V8中垃圾回收机制是怎么样的"},"children":[]},{"data":{"id":"czsjdx5db200","created":1710324362276,"text":"哪些操作会造成内存泄露"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}