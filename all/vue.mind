{"root":{"data":{"id":"d0054b7wc740","created":1711096593377,"text":"vue"},"children":[{"data":{"id":"d00558d6rww0","created":1711096665531,"text":"vue基础","layout_mind_offset":{"x":-51.99999845027958,"y":806.9999900162225}},"children":[{"data":{"id":"d0055hcx99c0","created":1711096685106,"text":"vue的基本原理","note":"数据劫持和发布者订阅者模式。\n创建 vue 实例的时候，会遍历 data 中的数据进行 Object.definepropty();\ngetter/setter,数据会被劫持，读和写数据的时候会触发。\n然后就是发布和订阅模式。\n（render 在渲染虚拟树的时候，触发 getter ，getter 会触发依赖收集，给到 watcher。\n这边 setter 触发之后，会通知给到 watcher，re-render 触发 render 函数，重新收集依赖给到 watcher）"},"children":[]},{"data":{"id":"d0055merviw0","created":1711096696102,"text":"双向数据绑定的原理","note":"关键字解释：\nObserve 负责将一个普通对象转换成响应式对象。（complie getter(dep.addDep(Dep.target));(obeserve setter(dep.notify()通知更新依赖，通知 watcher 更新视图))\n\nWatcher 监听变化。watcher 在实例化的时候会将自己添加到 Dep 中，最后回调触发 render 函数。\n\nDep 依赖收集者 ，管理 watcher。数据发生变化时,会通知 watcher。\n\n数据触发视图：\nObserver --通知变化--->Dep（收集新的依赖）---通知变化--> Watcher（收更新集之后，触发视图更新） ----->View\n\n视图触发数据（两条线）：\n= Compile(--------> Watcher （订阅者，拿到之后绑定更新函数 ，对数据进行写入）-->dep (属性依赖收集)\n==compile ---->view 视图更新"},"children":[]},{"data":{"id":"d0055vfb3cw0","created":1711096715725,"text":"使用Object.defineProperty 进行数据劫持有什么特点","note":"需要循环递归来完成完整的劫持，消耗性能。\n\n并且初始化之后，新增属性不能被劫持。使用下标操作数组不能被劫持到。\n\n对比 VUE3 使用的 proxy 就解决了这些问题，但是缺点是 ES6 语法，没办法很好的兼容"},"children":[]},{"data":{"id":"d0056bzg3080","created":1711096751771,"text":"MVVM、MVC、MVP设计模式的区别","note":"MVC 数据驱动视图 \n当 view 层有动作，controller 层的动作指令会上传到 module 层（qud）\n\n\nMVVM 数据视图双向驱动\nview 有动作会触发model层\n当 model 层出现变化，也会触发 view 更新\n\n\n\n"},"children":[]},{"data":{"id":"d0056qlr2cg0","created":1711096783595,"text":"computed和watch的区别"},"children":[]},{"data":{"id":"d0056xm9hso0","created":1711096798864,"text":"computed和methods的区别"},"children":[]},{"data":{"id":"d00575h9szk0","created":1711096815976,"text":"slot是什么？作用是什么？原理是什么？"},"children":[]},{"data":{"id":"d0057gcycq80","created":1711096839659,"text":"过滤器的作用？如何实现一个过滤器？"},"children":[]},{"data":{"id":"d0057vol0d40","created":1711096873014,"text":"如何保存页面当前的状态？"},"children":[]},{"data":{"id":"d005817koeg0","created":1711096885047,"text":"常见的事件修饰符和作用"},"children":[]},{"data":{"id":"d0058kk1h800","created":1711096927159,"text":"v-if、v-show、v-html的原理"},"children":[]},{"data":{"id":"d0058xtmbmo0","created":1711096956037,"text":"v-if 和 v-show的区别"},"children":[]},{"data":{"id":"d00593kqxrc0","created":1711096968561,"text":"v-model的语法糖怎么写的"},"children":[]},{"data":{"id":"d0059pmnrkw0","created":1711097016566,"text":"v-model能不能再自定义组件上使用？怎么去使用？"},"children":[]},{"data":{"id":"d005a5tqz340","created":1711097051823,"text":"data为什么是一个函数不是一个对象"},"children":[]},{"data":{"id":"d005ar1w6kg0","created":1711097098028,"text":"keep-alive的理解、实现。具体缓存的内容是什么？"},"children":[]},{"data":{"id":"d005b90q3xs0","created":1711097137139,"text":"$nextTick的原理和作用"},"children":[]},{"data":{"id":"d005bngcqps0","created":1711097168559,"text":"vue2 中给对象中添加新的属性会发生什么？怎么去解决？"},"children":[]},{"data":{"id":"d005c9u6on40","created":1711097217285,"text":"vue中封装的数组方法有哪些？其是怎么实现页面更新的"},"children":[]},{"data":{"id":"d005dl1ajxc0","created":1711097320023,"text":"vue单页面和多页面的区别"},"children":[]},{"data":{"id":"d005dtjyv800","created":1711097338567,"text":"vue template 到 render的过程"},"children":[]},{"data":{"id":"d005e7k7kso0","created":1711097369056,"text":"vue中某个对象属性的值发生改变，视图会立即同步渲染吗"},"children":[]},{"data":{"id":"d005elojfw80","created":1711097399793,"text":"简述mixin和extends的覆盖原理"},"children":[]},{"data":{"id":"d005f4j4sbk0","created":1711097440825,"text":"描述vue的自定义指令"},"children":[]},{"data":{"id":"d005fxez2ko0","created":1711097503700,"text":"子组件可以直接修改父组件内部的数据吗"},"children":[]},{"data":{"id":"d005gbp011k0","created":1711097534781,"text":"vue是如何收集依赖的"},"children":[]},{"data":{"id":"d005glpp6dk0","created":1711097556592,"text":"vue的优点"},"children":[]},{"data":{"id":"d005gq5c31c0","created":1711097566244,"text":"assets 和  static的区别"},"children":[]},{"data":{"id":"d005h7kjeao0","created":1711097604169,"text":"delete 和  vue.delete 删除数组的区别"},"children":[]},{"data":{"id":"d005htom9fk0","created":1711097652305,"text":"vue如何监听对象或者数组中某个属性的变化"},"children":[]},{"data":{"id":"d005i5ta1rk0","created":1711097678708,"text":"什么是mixin"},"children":[]},{"data":{"id":"d005ib9hd9k0","created":1711097690571,"text":"vue 模板编译的原理"},"children":[]},{"data":{"id":"d005ihxi0v40","created":1711097705084,"text":"对SSR的理解"},"children":[]},{"data":{"id":"d005imfx3ew0","created":1711097714905,"text":"vue的性能优化有哪些"},"children":[]},{"data":{"id":"d005ite7okw0","created":1711097730040,"text":"对SPA单页面的理解，他的优缺点分别是什么"},"children":[]},{"data":{"id":"d005j97gbxc0","created":1711097764459,"text":"vue初始化页面闪动的原因和解决"},"children":[]},{"data":{"id":"d005jti10ls0","created":1711097808634,"text":"mixin和mixins的区别"},"children":[]},{"data":{"id":"d005k2l484o0","created":1711097828412,"text":"extend有什么作用"},"children":[]},{"data":{"id":"d005k9ptimw0","created":1711097843934,"text":"MVVM的有缺陷点"},"children":[]}]},{"data":{"id":"d005koblapk0","created":1711097875725,"text":"生命周期","layout_mind_offset":{"x":-1110.2499593682605,"y":-1350.9999771416192}},"children":[{"data":{"id":"d005m300wi00","created":1711097986042,"text":"简单说一下vue的生命周期"},"children":[]},{"data":{"id":"d005mcaol400","created":1711098006277,"text":"vue中子组件和父组件的执行顺序"},"children":[]},{"data":{"id":"d005mnxzw5s0","created":1711098031632,"text":"created和mounted的区别"},"children":[]},{"data":{"id":"d005mv5dcuo0","created":1711098047315,"text":"一般使用哪个生命周期去请求异步数据"},"children":[]},{"data":{"id":"d005n5cmqj40","created":1711098069522,"text":"keepalive和生命周期"},"children":[]}]},{"data":{"id":"d005ksl5pm00","created":1711097885011,"text":"组件通信的方式","layout_mind_offset":{"x":-1322.9999605715284,"y":-576.9999962151053}},"children":[]},{"data":{"id":"d005l211ehs0","created":1711097905562,"text":"路由","layout_mind_offset":{"x":-1258.9999624788768,"y":-151.00000891089405}},"children":[{"data":{"id":"d005o0wuv940","created":1711098138225,"text":"Vue-Router的懒加载如何实现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005o8431aw0","created":1711098153900,"text":"hash和history模式的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005ohg5jug0","created":1711098174221,"text":"如何获取页面hash的变化","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oms79e80","created":1711098185833,"text":"route和$router 的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oy9c1400","created":1711098210813,"text":"如何获取动态路由？如何获取传过来的动态参数？","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005pedfr6o0","created":1711098245890,"text":"vue-Router路由钩子在生命周期中的体现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005prrucqo0","created":1711098275059,"text":"vue-router跳转和location.herf的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q1xngcg0","created":1711098297178,"text":"params和query的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q95kty80","created":1711098312895,"text":"vue-router的导航守卫有哪些","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005qjw0dz40","created":1711098336261,"text":"对前端路由的理解","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]}]},{"data":{"id":"d005l8fnfsw0","created":1711097919507,"text":"vuex","layout_mind_offset":{"x":-489.9999853968625,"y":-317.99999052286176}},"children":[{"data":{"id":"d005qzcn6w00","created":1711098369919,"text":"vuex的原理和自己的理解"},"children":[]},{"data":{"id":"d005rd6jcqo0","created":1711098400024,"text":"vue中action和mutation的区别"},"children":[]},{"data":{"id":"d005rpym3mg0","created":1711098427843,"text":"vuex和localstorage的 区别"},"children":[]},{"data":{"id":"d005rzn1do80","created":1711098448911,"text":"vuex有哪些属性"},"children":[]},{"data":{"id":"d005sa2j9940","created":1711098471616,"text":"vuex和单纯的全局对象有什么区别"},"children":[]},{"data":{"id":"d005sk0m9wg0","created":1711098493268,"text":"为什么不能再vuex的mutation中做异步操作"},"children":[]},{"data":{"id":"d005ssblpqg0","created":1711098511347,"text":"vuex中严格模式的作用，如何开启"},"children":[]},{"data":{"id":"d005t61v9dk0","created":1711098541233,"text":"如何批量使用vuex的getter属性"},"children":[]},{"data":{"id":"d005tf5mmmo0","created":1711098561051,"text":"如何在组件中重复使用vuex的mutation"},"children":[]}]},{"data":{"id":"d005lbsvtw00","created":1711097926837,"text":"vue3.0","layout_mind_offset":{"x":-697.9999791979795,"y":-321.9999904036524}},"children":[{"data":{"id":"d005u33dijk0","created":1711098613158,"text":"vue3 有哪些更新"},"children":[]},{"data":{"id":"d005u8uftkw0","created":1711098625678,"text":"dfineProperty和Proxy的区别"},"children":[]},{"data":{"id":"d005uiscqao0","created":1711098647320,"text":"vue3为什么要使用proxy"},"children":[]},{"data":{"id":"d005uqu2e680","created":1711098664838,"text":"vue3中compositionAPI"},"children":[]}]},{"data":{"id":"d005lfaqkxc0","created":1711097934447,"text":"虚拟DOM","layout_mind_offset":{"x":-697.9999791979797,"y":-193.9999942183495}},"children":[{"data":{"id":"d005v7utas00","created":1711098701888,"text":"对虚拟DOM的理解"},"children":[]},{"data":{"id":"d005vc8lkv40","created":1711098711429,"text":"虚拟DOM的解析过程"},"children":[]},{"data":{"id":"d005vk1o35s0","created":1711098728424,"text":"为什么要用虚拟DOM"},"children":[]},{"data":{"id":"d005voyg6c80","created":1711098739113,"text":"虚拟DOM真的比真实DOM的性能好吗"},"children":[]},{"data":{"id":"d005vy68lc80","created":1711098759175,"text":"DIff算法的原理"},"children":[]},{"data":{"id":"d005w3pt1280","created":1711098771243,"text":"vue中key 的作用"},"children":[]},{"data":{"id":"d005waeo98w0","created":1711098785807,"text":"为什么不建议使用index作为key"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}