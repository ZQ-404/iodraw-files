{"root":{"data":{"id":"d0054b7wc740","created":1711096593377,"text":"vue"},"children":[{"data":{"id":"d00558d6rww0","created":1711096665531,"text":"vue基础","layout_mind_offset":{"x":-51.99999845027958,"y":806.9999900162225}},"children":[{"data":{"id":"d0055hcx99c0","created":1711096685106,"text":"vue的基本原理","note":"数据劫持和发布者订阅者模式。\n创建 vue 实例的时候，会遍历 data 中的数据进行 Object.definepropty();\ngetter/setter,数据会被劫持，读和写数据的时候会触发。\n然后就是发布和订阅模式。\n（render 在渲染虚拟树的时候，触发 getter ，getter 会触发依赖收集，给到 watcher。\n这边 setter 触发之后，会通知给到 watcher，re-render 触发 render 函数，重新收集依赖给到 watcher）"},"children":[]},{"data":{"id":"d0055merviw0","created":1711096696102,"text":"双向数据绑定的原理","note":"关键字解释：\nObserve 负责将一个普通对象转换成响应式对象。（complie getter(dep.addDep(Dep.target));(obeserve setter(dep.notify()通知更新依赖，通知 watcher 更新视图))\n\nWatcher 监听变化。watcher 在实例化的时候会将自己添加到 Dep 中；可以执行回调触发 render 函数。\n\nDep 依赖收集者 ，管理 watcher。数据发生变化时,会通知 watcher。\n\n数据触发视图：\nObserver --通知变化--->Dep（收集新的依赖）---通知变化--> Watcher（收更新集之后，触发视图更新） ----->View\n\n视图触发数据（两条线）：\n= Compile(--------> Watcher （订阅者，拿到之后绑定更新函数 ，对数据进行写入）-->dep (属性依赖收集)\n==compile ---->view 视图更新"},"children":[]},{"data":{"id":"d0055vfb3cw0","created":1711096715725,"text":"使用Object.defineProperty 进行数据劫持有什么特点","note":"需要循环递归来完成完整的劫持，消耗性能。\n\n并且初始化之后，新增属性不能被劫持。使用下标操作数组不能被劫持到。\n\n对比 VUE3 使用的 proxy 就解决了这些问题，但是缺点是 ES6 语法，没办法很好的兼容"},"children":[]},{"data":{"id":"d0056bzg3080","created":1711096751771,"text":"MVVM、MVC、MVP设计模式的区别","note":"MVC 数据驱动视图 \n当 view 层有动作，（动作指令作用在controller）controller 层的动作指令会上传到 （选择模型）model 层（驱动视图更新）\n\n\nMVVM 数据视图双向驱动\nview 有动作会触发model层\n当 model 层出现变化，也会触发 view 更新\n\n\n\n"},"children":[]},{"data":{"id":"d0056qlr2cg0","created":1711096783595,"text":"computed和watch的区别","note":"computed 是读缓存的，性能消耗小，当依赖数据发生改变时触发，不支持异步\n\nwatch 没有缓存，性能消耗大，自身变换触发，支持异步"},"children":[]},{"data":{"id":"d0056xm9hso0","created":1711096798864,"text":"computed和methods的区别","note":"computed 依赖的属性变化是触发\nmethods 调用的时候触发"},"children":[]},{"data":{"id":"d00575h9szk0","created":1711096815976,"text":"slot是什么？作用是什么？原理是什么？","note":"插槽：封装组件的时候预留的。使用的时候可以往里面插入内容。\n插槽分成三种：默认、具名、作用域\n\n默认（匿名）插槽\n\n```html\n<slot ><slot>\n<left><template></tempalte></left>\n```\n\n具名插槽\n\n```html\n<slot name=\"slotname\"></slot> <left> <template #slotname> </template> </left>\n```\n\n作用域插槽\n\n```html\n<slot name=\"slotname\" age=\"12\" name=\"zhangsan\"> </slot>\n<left>\n  <template #slotname=\"scope\"> {{scope.name}} {{scope.age}} </template>\n</left>\n```\n\n原理：。。"},"children":[]},{"data":{"id":"d0057gcycq80","created":1711096839659,"text":"过滤器的作用？如何实现一个过滤器？","note":"可以让一个数据不改变值的情况下，以另一种形式展示\n与 data 同级下面使用\n\n```js\nfilters:{\n\tgetNumber(value){\n\t\treturn value ;\n\t},\n}\n```\n\n使用插值表达式和管道符搭配使用 {{value | getNumber}}"},"children":[]},{"data":{"id":"d0057vol0d40","created":1711096873014,"text":"如何保存页面当前的状态？","note":"页面销毁\n存储到浏览器本地 sessionstorage localstorage\n路由传值，路由拿值\n页面不销毁\nkeepalive 进入生命周期 activated 、deactivated"},"children":[]},{"data":{"id":"d005817koeg0","created":1711096885047,"text":"常见的事件修饰符和作用","note":".stop 阻止冒泡 阻断内部冒泡\n.prevent 阻止默认行为\n.capture 阻止事件捕获\n.self 忽略内部冒泡事件带节奏，只响应自身事件  \n.once 值触发一次"},"children":[]},{"data":{"id":"d0058kk1h800","created":1711096927159,"text":"v-if、v-show、v-html的原理","note":"vif 不进行 render\nvshow display:none\nv-html   新建一个DOM元素，修改innerHTML的属性值"},"children":[]},{"data":{"id":"d0058xtmbmo0","created":1711096956037,"text":"v-if 和 v-show的区别","note":"vif 删除和添加 DOM，会造成重构，更消耗切换消耗，元素被删除\n\nvshow 给元素设置属性，会造成重绘，消耗除渲染消耗，元素被隐藏，占文档位置\n通过display：none的属性"},"children":[]},{"data":{"id":"d00593kqxrc0","created":1711096968561,"text":"v-model的语法糖怎么写的","note":"<v-input :value='message' @input='message=$event.target.value'>"},"children":[]},{"data":{"id":"d0059pmnrkw0","created":1711097016566,"text":"v-model能不能再自定义组件上使用？怎么去使用？","note":"自定义组件可以使用v-model，使用的方式就是，通过props和$emit 去实现。\n\n自定组件的使用\n<my-componet :model=\"message\"></my-component>\n\n\n\n自定义组件的编写\n\nprops:{\nmessage:'',\n}\n\nchange(){\n"},"children":[]},{"data":{"id":"d005a5tqz340","created":1711097051823,"text":"data为什么是一个函数不是一个对象","note":"封装成函数，存在函数作用域，组件复用的时候，数据读写就不会相互干扰。"},"children":[]},{"data":{"id":"d005ar1w6kg0","created":1711097098028,"text":"keep-alive的理解、实现。具体缓存的内容是什么？","note":"三个属性\ninclude 正则表达式、字符串\nexclude\nmax 数字，字符数字，达到最大，前面组价会被 move 掉，\n最新进来的继续 keepalive"},"children":[]},{"data":{"id":"d005b90q3xs0","created":1711097137139,"text":"$nextTick的原理和作用","note":"最新的 DOM 元素渲染完成之后，执行。作用：\ncreated()钩子函数中，页面的 DOM 还未渲染，这时候也没办法操作 DOM，所以，此时如果想要操作 DOM，必须将操作的代码放在 nextTick()的回调函数中。"},"children":[]},{"data":{"id":"d005bngcqps0","created":1711097168559,"text":"vue2 中给对象中添加新的属性会发生什么？怎么去解决？","note":"因为 vue2 拦截是用的是 Object.definProperty(),初始化的时候会对数据进行劫持\n后面加的对象属性，不是响应式的，数据更新但视图不会更新\n解决方法\nthis.$set(this.obj,'b','dkkd')\n如果是 VUE3 使用的 proxy 就不会出问题"},"children":[]},{"data":{"id":"d005c9u6on40","created":1711097217285,"text":"vue中封装的数组方法有哪些？其是怎么实现页面更新的","note":"vue 使用的是 Object.defineProperty 这个方法没有办法对数据的内部进行监听\n需要经过特殊的处理，将 JS 数组的原生方法汇总成数组，只要匹配到就对数组\n数据进行操作 push pop unshift shift splice sort reverse"},"children":[]},{"data":{"id":"d005dl1ajxc0","created":1711097320023,"text":"vue单页面和多页面的区别","note":"SPA 表示单页面开发，加载一次资源，刷新局部资源即可，路由模型 hash history，数据传输VUEX,前期劳动成本高，后期维护成本低。\n\n\n\n\nMPA 表示多页面开发，多次发 http 请求资源费钱，路由只能普通跳转链接，数据传输cookie localStorage ，前期劳动成本低，后期维护成本高。\n\n\n\n扩展 SSR 服务端渲染， SEO 搜索引擎优化\n(SPA 不利于 SEO，可以借助 SSR 优化)MPA 是利于 SEO 的。"},"children":[]},{"data":{"id":"d005dtjyv800","created":1711097338567,"text":"vue template 到 render的过程","note":"template==>ast（抽象语法树）==>render\n\n\n第一步：调用 parse 方法将 template，type 参数分别调用表达式、纯文本、普通元素对应的方法，生成 ast 树。\n\n第二步：对静态节点做优化 optimize(ast,options) 对 ast 数进行深度遍历，摘除静态节点，为后续的模板更新做 优化。\n\n\n第三步：generate(ast,options) ast 通过 generate 被编译成 render 字符串。在通过 new Function（'render'） 生成函数，方便调用执行。"},"children":[]},{"data":{"id":"d005e7k7kso0","created":1711097369056,"text":"vue中某个对象属性的值发生改变，视图会立即同步渲染吗","note":"不会。为了减少性能消耗，vue 有一个去重机制。watcher 被触发之后会进入事件队列,事件队列去重之后才回去执行视图渲染的工作。"},"children":[]},{"data":{"id":"d005elojfw80","created":1711097399793,"text":"简述mixin和extends的覆盖原理","note":"都是通过 mergeOptions 方法去实现的\nmixins接收一个混入对象的数组，在调用组件自身的钩子之前被调用。\nextends接收一个对象或构造函数，（如下面写法不同）\n\nmixins: [mixin1, mixin2],\nextends: extend,\n合并策略 1 ：先 mixin 和 extend 里面的回调 然后再调用组件自身的回调 ； hooks 生命周期钩子函数，先执行 mixins 和 extend 是里面的，然后再执行自身的\n合并策略 2：其他的 options 都是将 将组件上没有的合并上去，有的使用默认的值\n\n1、watch 以及生命钩子函数的执行顺序，先执行 mixins 和 extends 里面的，再去执行自身的\n2、mergeOptions 对 vue 实例中的 options 依次进行合并，新定义一个 options ，并将这个 新 options 返回出去"},"children":[]},{"data":{"id":"d005f4j4sbk0","created":1711097440825,"text":"描述vue的自定义指令","note":"虽然 vue 不推崇操作 DOM，但是在复杂的业务环境中，操作 DOM 也是难免的，这个时候就可以使用自定义指令去操作 DOM\n全面自定义指令：Vue.directive(\"xxx\",{})\n局部自定义指令 :directive:{'xxx':{}}\n常用的钩子函数有 bind mounted update componentUpdated unbind\n这些钩子函数在不同的生命周期中被调用\n比如下面的自定义指令代码\n\n```js\ndiretive:{\n  loading:{\n    inserted(el,binding){\n      // el  表示当前被绑定自定义指令的元素节点\n      // binding 表示自定义指令时传入的参数\n      // binding.value 其实就是  isShow 的值\n\n    },\n    update(el,binding){\n\n    },\n  }\n}\n```\n\n```html\n<div v-loading=\"isShow\"></div>\n```"},"children":[]},{"data":{"id":"d005fxez2ko0","created":1711097503700,"text":"子组件可以直接修改父组件内部的数据吗","note":"不可以，以为 VUE 提倡单向数据流，防止数据流混乱。\n允许父修改子数据，如果需要修改通过$emit"},"children":[]},{"data":{"id":"d005gbp011k0","created":1711097534781,"text":"vue是如何收集依赖的","note":"data 初始化的时候，会进行数据拦截，会在这个时候进行依赖收集"},"children":[]},{"data":{"id":"d005gq5c31c0","created":1711097566244,"text":"assets 和  static的区别","note":"相同点：都是储存静态资源文件的地方\n\n不同点：assets 在项目打包的时候会被打包、static 不会被打包\n\n项目中自己写的 JS 可以放在 assets 中，引入的第三方 JS 文件放到 static 中."},"children":[]},{"data":{"id":"d005h7kjeao0","created":1711097604169,"text":"delete 和  vue.delete 删除数组的区别","note":"不同点：\ndelete 删除的元素变成 undefined/empty 。\nVue.delete 直接删除数组，改变数组键值对。\n代码如下：\nlet arr = [1, 2, 3, 4, 5]\ndelete arr[2] //输出 arr 为 👉[1, 2, empty, 4, 5]\nVue.delete(arr, 2) //输出 arr 为 👉[1, 2, 4, 5]\n\n\n相同点：\n删除对象属性的时候，输出的内容是一样的。但是 vue.delete 删除之后可以触发视图更新，delete 删除之后视图得不到更新\nlet obj = { name: 'zs', age: 12 }\nVue.delete(obj, 'name'); //输出obj为👉{age: 12}\ndelete obj.name; //输出obj为👉{age: 12}\n"},"children":[]},{"data":{"id":"d005htom9fk0","created":1711097652305,"text":"vue如何监听对象或者数组中某个属性的变化","note":"vue2 监听不到属性的变化、this.$set(数组/对象，索引/属性，值)\n对象会判断是不是响应式属性，如果是响应式就直接操作，不是响应式就需要对属性进行数据劫持，添加响应式\n\n数组会调用 splice，或者调用数组的原型链，vue 源码中对数组操作的方法进行了重写。听过匹配重写的数组方法也可以触发响应式"},"children":[]},{"data":{"id":"d005i5ta1rk0","created":1711097678708,"text":"什么是mixin","note":"vue 组件中进行插拔和复用。如果需要使用，只需要引入文件，\n放入 mixin 中 ，就能混入到组件中，可以直接用 this 去调用，非常方便\n扩展 mixin 和 mixins 的区别，mixin 是全局混入的写法，mixins 是局部引入的写法。\n\n```js\n// main.js\nimport mixin from \"./mixin.js\";\nVue.mixin(mixin);\n\n// 单个vue文件\nimport { myMixin } from \"./mixin.js\";\nexport default {\n  mixins: [myMixin];\n}\n```"},"children":[]},{"data":{"id":"d005ib9hd9k0","created":1711097690571,"text":"vue 模板编译的原理","note":"(三个阶段：解析阶段、优化阶段、生成阶段)\n\n\ntemplate 无法直接被浏览器解析并渲染，需要解析 parse、\noptimize 优化成 generate\n然后执行 render 函数"},"children":[]},{"data":{"id":"d005ihxi0v40","created":1711097705084,"text":"对SSR的理解","note":"服务端渲染。vue 在服务端将代码渲染成超文本语言，然后将渲染好的 HTML\n返回给客户端。\n优点：可以优化SPA的 SEO 、首屏加载速度更快\n缺点：更多的服务端负载、需要 node.js 运行环境、\n开发条件收到限制，只支持 beforCreate 和 created 两个钩子函数。"},"children":[]},{"data":{"id":"d005imfx3ew0","created":1711097714905,"text":"vue的性能优化有哪些","note":"(1)编码阶段\n1、减少 data 中的数据，因为 vue 实例化的时候会对 getter 和 setter、会消耗性能\n2、vif 和 vfor 不能连用\n因为 vue2 中 vfor 的优先级是高于 vif，所以如果连用，会先执行 vfor，\n然后逐个执行 vif，vif 是性能消耗比较高。\nvue3 中 vif 优先级高于与 vfor 是可以连用的\nvue2 中解决方法，① 对 list 进行过滤 ②vif 包裹在外面\n3、不适用 vfor 对元素进行逐个绑定事件，可以使用事件代理的方式\n在子元素上绑定指定以属性<div v-for='item in list ' :key='item' :data-XXX='item' ></div>，\n在父元素上绑定点击事件 @click='onClick(e)'，\n通过 e.target.getAttribute('data-XXX');\n获取子元素的属性值\n4、SPA 页面使用 keepalive 缓存组件\n5、如果不是频繁切换，使用 vif 代替 vshow\n6、使用 key、 保证 DOM 的唯一性\n7、使用路由懒加载，异步加载组件。\nwebpack 会将 vue 打包成单独的 JS 文件，\n当请求发出之后，在对相应的路由进行请求发送\n8、防抖、节流\n防抖：第一次 A 事件和第二次 B 事件，他们之间时间间隔需要在指定时间内，\n多次触发同一个事件，只执行最后一次操作。比如输入框中输入数据，将一段时间内的多次触发，合并成最后一次\n才会执行 A 事件\n节流：保护时间内只执行一个 A 事件，保护时间结束再去执行 B 事件\n多次触发同一个事件，只执行第一次操作。\n9、第三模块按需引入\n10、长列表动态化加载(分页)\n11、图片懒加载\n\n(2)SEO 优化\n1、预渲染\n2、服务端渲染 SSR\n\n\n(3)打包优化\n1、压缩代码\n2、Tree Shaking/Scope Hoisting\n3、使用 CDN 加载第三方模块\n4、多线程打包 happypack\n5、splitChunks 抽离公共文件\n6、sourceMap 优化\n\n(4)用户体验\n骨架屏\nPWA\n还可以使用缓存 客户端缓存、服务端缓存"},"children":[]},{"data":{"id":"d005ite7okw0","created":1711097730040,"text":"对SPA单页面的理解，他的优缺点分别是什么","note":"优势：用户体验好、快、内容改变不需要重新加载整个页面、避免不必要的跳转和渲染。\nSPA 对服务器压力小\n前后端分离、前端交互逻辑、后端数据处理、\n缺点：\n初次加载耗时所、\n不能使用浏览器自带路由、需要自己建立堆栈管理\n不利于 SEO、可以借助 SSR 服务端渲染"},"children":[]},{"data":{"id":"d005j97gbxc0","created":1711097764459,"text":"vue初始化页面闪动的原因和解决","note":"vue 初始化之前，使用 div 不归 vue 管、 没有解析的情况下会出现花屏看到类似于{{message}}的字样，\n处理的办法：就是在根元素上加上这些属性 display:none display:block"},"children":[]},{"data":{"id":"d005jti10ls0","created":1711097808634,"text":"mixin和mixins的区别","note":"mixin 全局混入，会影响到每个组件的 beforeCreate 周期，\n将封装的内容注入到每一个组件中 Vue.mixin('mixin')\n\nmixins 相当于一个组件，会和父组件一起形成一个新父组件，不需要 props 传参"},"children":[]},{"data":{"id":"d005k2l484o0","created":1711097828412,"text":"extend有什么作用","note":"扩展组件生成一个构造器\nvue.extend({template:'<div>test</div>'}).$mount('#app')//\n//作用：扩展组件生成一个构造器"},"children":[]},{"data":{"id":"d005k9ptimw0","created":1711097843934,"text":"MVVM的有缺陷点","note":"优点：\n分离视图和模型,降低耦合性，减少了 DOM 的操作\n\n缺点：\nbug 定位变难，因为是数据双向绑定，一处问题可以会影响到好几处"},"children":[]}]},{"data":{"id":"d005koblapk0","created":1711097875725,"text":"生命周期","layout_mind_offset":{"x":-1177.249957371505,"y":-1434.999974638224}},"children":[{"data":{"id":"d005m300wi00","created":1711097986042,"text":"简单说一下vue的生命周期","note":"beforeCreate vue 实例创建前，暂时访问不了 options 中的属性\ncreated 创建后，这个时候能访问 options 中属性了\nbeforeMount 挂载前，进行模板编译\nmounted 挂载后，进行数据挂载\nbeforeUpdate 更新前，数据更新了，但是视图没有更新\nupdated 更新之后，数据和视图都更新了\nbeforeDestroy 实例销毁之前，这个阶段 this 任然能获取到实例\ndestoryed 销毁后，这个阶段 this 已经获取不到实例了"},"children":[]},{"data":{"id":"d005mcaol400","created":1711098006277,"text":"vue中子组件和父组件的执行顺序","note":"44、vue 子组件和父组件执行顺序\n加载渲染过程：\n1、父组件 beforeCreate\n2、父组件 created\n3、父组件 beforeMount(挂载之前，插入子组件钩子)\n4、子组件 beforeCreate\n5、子组件 created\n6、子组件 beforeMount\n7、子组件 mounted\n8、父组件 mounted\n更新过程：\n1、父组件 beforeUpdate\n2、子组件 beforeUpdate\n3、子组件 updated\n4、父组件 updated\n销毁过程\n1、父组件 beforeDestroy\n2、子组件 beforeDestroy\n3、子组件 destroyed\n4、父组件 destroyed"},"children":[]},{"data":{"id":"d005mnxzw5s0","created":1711098031632,"text":"created和mounted的区别","note":"created：模板渲染成 html 之前，能获取到 data methods  \n 但是获取不到 DOM\nmounted：能获取到真实 DOM"},"children":[]},{"data":{"id":"d005mv5dcuo0","created":1711098047315,"text":"一般使用哪个生命周期去请求异步数据","note":"created 以及 created 的生命钩子函数中调用\ncreated、beforeMount、mounted 中都能调用。\n推荐 created 钩子函数调用异步请求，created 请求的优势：\n1、更快的获取服务端数据、减少页面加载时间，用户体验好\n2、SSR 不支持 beforeMount、mounted 钩子函数、放在 created 有助一致性"},"children":[]},{"data":{"id":"d005n5cmqj40","created":1711098069522,"text":"keepalive和生命周期","note":"组件被 keep-alive 包裹之后，那么这个两个组件\nactived 组件被切回来\ndeactived 组件被切走，处于缓存状态"},"children":[]}]},{"data":{"id":"d005ksl5pm00","created":1711097885011,"text":"组件通信的方式","layout_mind_offset":{"x":-1290.999961525203,"y":-675.9999932646754},"note":"1、props $emit\n父组件通过 props 向子组件传数据  \n //父组件中代码  \n <son  :name-data='nameData'></son>\ndata(){\nreturn {\nnameData:'我是父组件传给子组件的',\n}\n}\n//子组件\nprops:{\nnameData:{\ntype:'string',\n}\n}\n\n    子组件通过 $emit 向父组件传数据\n    //父组件中\n    <son @dateName='getDataName'></son>\n    getDataName(val){\n    \tconsole.log(val);//子组件传递过来的数据\n    }\n    //子组件($emit 可以放到任何位置，子组件一旦触发，父组件就能接到子组件的数据)\n\n    craeted(){\n    \tthis.$emit('dateName',dataName)\n\n    }\n    2、eventBus事件总线($emit /$on )   使用父子组件、非父子组件\n     使用步骤：先创建一个eventBus.js    在JS里面创建一个vue实例，并将其导出去\n     import vue from 'vue'\n     let eventBus =new vue();\n     export default eventBus;\n\n     发送方import  eventBus from 'eventBus.js'\n    \t eventBus.$emit('sendData',val)\n     接收方 import  eventBus from 'eventBus.js'\n    \teventBus.$on('sendData',(val)=>{console.log(val,'=========')})\n\n    3、依赖注入(provide/inject)  数据不是响应式的\n    祖孙组件之间传值/父子组件传值\n    provide inject和data   methods一样属于options里面的内容\n    provide用来发送数据或者方法\n    inject 用来接收数据或者方法\n    发送方\n    provide(){\n    \treturn {\n    \t\tnum:'12',\n    \t}\n    }\n    接收方\n    inject:['num'];\n    使用：this.num;//类似data中的数据\n\n    4、ref  /$refs  可以实现父子组件之间的通讯\n    //父组件中\n    <template>\n    \t<son ref='son'></son>\n    </template>\n    this.$refs.son.nameData;//获取子组件中的数据\n    this.$refs.son.getNameData();//调用子组件中的方法\n\n    5、$parent    $children\n    $parent 访问自己父组件的数据   this.$parent.msg\n    $root 访问根组件\n    $children  访问子组件的内容   (不止一个子组件，且子组件的顺序不能保证)\n    this.$children[0].msg\n    关于最高层组件和最底层组件的$children $parent的取值\n    #app   取  $parent   是  new Vue()\n    实例上取 $parent  是undefined\n    最底层取$children 是一个空的数组\n    6、$attrs / $listeners"},"children":[]},{"data":{"id":"d005l211ehs0","created":1711097905562,"text":"路由","layout_mind_offset":{"x":-1334.9999602139,"y":-321.00000384449936}},"children":[{"data":{"id":"d005o0wuv940","created":1711098138225,"text":"Vue-Router的懒加载如何实现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"1、import  \n const List= ()=>import ('@/components/List.vue');\nconst router =new VueRouter({\nroutes:[\n{path:'/list',component:List}\n]\n);\n2、require(path,res)\nconst router =new VueRouter({\nroutes:[\n{path:'/list',component:'(res)=>require(['@/components/List.vue'],res)}\n]\n})\n\n3、require ensure\nconst List =r=>require.ensure([],()=>r(require('@/component/list))),'list');\nconst router =new Router({\nroutes:[{\npath:'/list',\ncomponent:List,\nname:'list'\n}]\n})"},"children":[]},{"data":{"id":"d005o8431aw0","created":1711098153900,"text":"hash和history模式的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"一、hash # 路由变换不需要请求后端；history 没有# 路由变化需要请求后端,如果没有对应的路由或者资源就会刷出 404.\n二、hash 发生 url 变化成不同值的时候才会入栈，historyurl 值不改变也可以入栈\n三、hash 只能添加短字符串，history 可以添加任意类型到栈中\n四、hash 修改的是#后面的内容 ，history 可以修改这个 url\n五、history 可以设置额外的 title"},"children":[]},{"data":{"id":"d005ohg5jug0","created":1711098174221,"text":"如何获取页面hash的变化","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"1、深度监听$route 的变化\n2、window.location.hash"},"children":[]},{"data":{"id":"d005oms79e80","created":1711098185833,"text":"route和$router 的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"$route 访问的路由信息对象 path params hash nane fullPath 等\n$router 访问的是路由实例 可以访问到钩子函数、跳转方法等"},"children":[]},{"data":{"id":"d005oy9c1400","created":1711098210813,"text":"如何获取动态路由？如何获取传过来的动态参数？","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"1、param 方式\n配置路由格式 /router/:id\n<router-link  to=\"/user/+userId\"></router-link>\n{\npath:'/user/:userid',\ncomponent:User,\n}\n<router-link :to=\"{name:'users',params:{uname:wade}}\"></router-link>\nthis.$router.push({name:'user',params:{uname:wade}})\n\tthis.$router.push('/user/'+wade)\n通过 $route.params.userid 获取传递的值\n \t\n\t\n\t2、query方式\n\t/router   普通配置  \n\t/route?id=123   传递方式\n\t传递方式   \n\t<router-link :to=\"{path:'/profile',query:{name:'why',age:28}}\"></router-link>\n\tprofileClick(){\t\n\t\tthis.$router.push({\npath:'/profile',\nquery:{\nname:'kobi'\n}\n\n    \t})\n    }\n    $route.query  获取传递的值"},"children":[]},{"data":{"id":"d005pedfr6o0","created":1711098245890,"text":"vue-Router路由钩子在生命周期中的体现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"vue-router 全局三个路由钩子\nrouter.beforeEach 全局前置守卫\nrouter.beforeResolve 全局解析守卫 在 beforeRouteEnter 调用之后\nrouter.aftreEach 全局后置钩子，进入路由之后\n使用场景  \n router.beforeEach 路由跳转之前，进行登录校验，登录校验通过就进入，\n没通过校验就进入登录界面\nrouter.afterEach 跳转之后，回到页面顶部\nto 、form 、next()\n组件内钩子\nbeforRouteUpdate、组件之间跳转 foo/:id id 复用组件被重复渲染时，会调用这个\nbeforeRouteEnter、当前组件地址改变并且\nbeforeRouteLeave、组件离开时被调用\n\nbeforeRouteEnter(to,from,next){\nnext(target=>{\n})\n}\n\nVue 路由钩子在生命周期函数的体现\n触发进入其他路由\nbeforeRouteLeave\nbeforeEach\nbeforeRouteUpdate\nbeforeEnter\n解析异步组件\nbeforeRouteEnter\nbeforeResolve\n导航被确认\n全局后置钩子 afterEach\n触发 DOM 更新 mountes\n执行 beforeRouteEnter 守卫中传给 next 的回调函数\n2.触发钩子完整顺序\n路由导航、keep-alive 、组件生命周期钩子结合、假设从 A 组件离开，第一次进入 B 组件\n路由组件离开之前，可以取消路由离开\nbeforeEach 路由全局守卫，用于登录验证、全局路由 loading 等\nbeforeEnter 路由独享守卫\nbeforeRouteenter 路由组件进入路由前钩子\nbeforeResolve 路由全局解析守卫\nafterEach 路由全局后置钩子\nbeforeCreate 组件生命周期，不能访问 data\ncreated 组件生命周期 访问 data，不能访问 DOM\nbeforeMount 组件生命周期，\ndeactivated:离开缓存组件 A,或者触发 A 的 beforeDestroy 和 destroyed 组件销毁钩子\nmounted 访问操作 dom\nactivated 进入缓存组件，\nbeforeRouteEnter 回调函数 next\n\n3、导航行为被触发到导航完成的整个过程\n导航行为被触发，导航未被确认\n失活组件里调用离开守卫 beforeRouteLeave\n调用全局 beforeEach 守卫\n重用组件调用 beforeRouteUpdata\n在路由配置里调用 beforeEnteY\n解析异步路由组件\n被激活组件里调用 beforeRouteEnter\n调用全局的 beforeResolve 守卫\n导航被确认\n调用全局的 afterEach 钩子\n非重用组件，开始组件实例的生命周期：beforeCreate&created、beforeMount&mounted\n触发 DOM 更新\n用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数\n导航完成"},"children":[]},{"data":{"id":"d005prrucqo0","created":1711098275059,"text":"vue-router跳转和location.herf的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"location.href 跳转，刷新页面\nhistory.pushState 无刷新页面，静态跳转\n$router.push 使用了 diff 算法，按需加载，减少 DOM 渲染的消耗。vue-router 就是使用\nhistory.pushState 完成的"},"children":[]},{"data":{"id":"d005q1xngcg0","created":1711098297178,"text":"params和query的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"query 在 url 中是会显示数据的，params 不会显示\nquery 刷新页面不丢失数据，params 刷新会丢失数据"},"children":[]},{"data":{"id":"d005q95kty80","created":1711098312895,"text":"vue-router的导航守卫有哪些","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"全局前置钩子：beforeEach、beforeResolve、afterEach\n路由独享守卫 beforeEnter\n组件内守卫： beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave"},"children":[]},{"data":{"id":"d005qjw0dz40","created":1711098336261,"text":"对前端路由的理解","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356},"note":"SPA 提高了用户体验，但是 url 记录没有，为了记录 url 的状态，和解决其他问题，前端路由出现了。会感知 url 的变化，拦截对服务端发通知，处理对应的渲染"},"children":[]}]},{"data":{"id":"d005l8fnfsw0","created":1711097919507,"text":"vuex","layout_mind_offset":{"x":-489.9999853968625,"y":-317.99999052286176}},"children":[{"data":{"id":"d005qzcn6w00","created":1711098369919,"text":"vuex的原理和自己的理解","note":"Vue Components 负责接收用户操作等交互行为\ndispatch 执行 action\nactions 提交 mutation 操作\ncommit 状态修改提交，唯一能执行 mutation 的方法\nmutations 修改 state 唯一推荐的方法\nstate 页面状态管理器对象。\ngetter state 对象读取的方法"},"children":[]},{"data":{"id":"d005rd6jcqo0","created":1711098400024,"text":"vue中action和mutation的区别","note":"action是异步的mutation\n\nmutation不支持异步"},"children":[]},{"data":{"id":"d005rpym3mg0","created":1711098427843,"text":"vuex和localstorage的 区别","note":"（1）vuex 是存储在内存中\nlocalstorage 则以文件的方式存储在本地，只能存储字符串类型数据，\n存储对象需要进行 JSON 处理\n内存速度会比硬盘速度快。\n(2)应用场景 vuex 组件之间传值\nlocalstorage 本地储存，存储到浏览器中，跨页面传递数据使用。\nvuex 能做成响应式，localstorage 不能做成响应式。\n刷新页面 vuex 存储的值会丢失，localstorage 不会。\nvuex 刷新会丢失数据，localstorage 刷新不会丢失数据。"},"children":[]},{"data":{"id":"d005rzn1do80","created":1711098448911,"text":"vuex有哪些属性","note":"state =>基本数据\ngetters=>基本数据派生出来的数据\nmutations=>提交更改数据的方法\nactions=>像一个装饰器，包裹 mutations,"},"children":[]},{"data":{"id":"d005sa2j9940","created":1711098471616,"text":"vuex和单纯的全局对象有什么区别","note":"vuex 中所有的状态存储是响应式的。全局对象可以直接修改，并且状态修改不会记录\nvuex 修改状态，会被记录"},"children":[]},{"data":{"id":"d005sk0m9wg0","created":1711098493268,"text":"为什么不能再vuex的mutation中做异步操作","note":"mutation 是修改状态的唯一途径，如果支持异步就不能准确的定位状态修改的时间\n，调试困难"},"children":[]},{"data":{"id":"d005ssblpqg0","created":1711098511347,"text":"vuex中严格模式的作用，如何开启","note":"vuex 开启严格模式之后，只能通过 mutation 对状态进行修改，如果不是就会报错\n如何开启：在 vuex.store 构造器选项中开启\nconst store =new Vuex.Store({\nstrict:true,\n})"},"children":[]},{"data":{"id":"d005t61v9dk0","created":1711098541233,"text":"如何批量使用vuex的getter属性","note":"使用 mapGetters 辅助函数，利用 ES6 解构语法可以将 getter 混入到 computed 对象中\nimport {mapGeeters} from 'vuex'\nexport default{\ncomputed:{\n...mapGeeters(['total',discountTotal'])\n}"},"children":[]},{"data":{"id":"d005tf5mmmo0","created":1711098561051,"text":"如何在组件中重复使用vuex的mutation","note":"import {mapMutations} from 'vuex'\nmethoss:{\n...mapMutations({\nsetNumber:'SET_NUMBER',\n}）\n}\n这个时候调用 this.setNumber(10) 就相当于 this.$store.commit('SET_Number')"},"children":[]}]},{"data":{"id":"d005lbsvtw00","created":1711097926837,"text":"vue3.0","layout_mind_offset":{"x":-697.9999791979795,"y":-321.9999904036524}},"children":[{"data":{"id":"d005u33dijk0","created":1711098613158,"text":"vue3 有哪些更新","note":"(1)监听机制发生改变\nvue3 中用 proxy 去实现监听\nvue2 使用 Object.defineProperty 实现监听，但是有很多问题：\n监听不到对象属性的添加和删除\n检测不到数组索引长度和变更\n支持 Map、Set、WeakMap、WeakSet"},"children":[]},{"data":{"id":"d005u8uftkw0","created":1711098625678,"text":"dfineProperty和Proxy的区别","note":"defineProperty 不能监听对象属性、数组变化\nproxy 可以监听对象以及对象下面的属性、以及数组"},"children":[]},{"data":{"id":"d005uiscqao0","created":1711098647320,"text":"vue3为什么要使用proxy","note":"不需要使用 vue，$set $delete 去触发响应式\n全方位数组变化检测，消除 vue2 无效边界问题"},"children":[]},{"data":{"id":"d005uqu2e680","created":1711098664838,"text":"vue3中compositionAPI","note":"便于使用者使用 ，vue2 中使用的 options API 不够灵活\n且在 TS 中是不能使用的，但是 vue3 是可以使用 TS 的"},"children":[]}]},{"data":{"id":"d005lfaqkxc0","created":1711097934447,"text":"虚拟DOM","layout_mind_offset":{"x":-697.9999791979797,"y":-193.9999942183495}},"children":[{"data":{"id":"d005v7utas00","created":1711098701888,"text":"对虚拟DOM的理解","note":"虚拟 DOM 是用一个 Object 对 DOM 进行抽象描述。\n有利于 SSR(Node.js 不支持 DOM，但是支持虚拟 DOM)、\ndiff 比较新旧虚拟 DOM，可以减少页面重排重绘的次数，提高渲染效率\n减少真实 DOM 的渲染，可以提高效率"},"children":[]},{"data":{"id":"d005vc8lkv40","created":1711098711429,"text":"虚拟DOM的解析过程","note":"当数据发生改变，需要对页面的 DOM 结构进行调整、构架出一个新对象树，对比就旧象树和新对象树，更新差异到真实 DOM，\n\n```js\n虚拟 DOM 的解析过程：\n首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。\n\n当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。\n\n最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。\n```\n"},"children":[]},{"data":{"id":"d005vk1o35s0","created":1711098728424,"text":"为什么要用虚拟DOM","note":"页面渲染的过程：\n解析 HTML->生成 DOM->生成 CSSDOM->Layout->Paint ->Compiler\n真实 DOM:生成 HTML 字符串，重建所有的 DOM 元素，\n虚拟 DOM：生成 vNode+DOMDiff+必要的 DOM 更新\n减少重排重绘次数，提高效率\n虚拟 DOM 可以跨平台，服务端渲染，uniapp 等\n\n```js\n（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能\n看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler\n下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶\n\n真实DOM∶ 生成HTML字符串＋重建所有的DOM元素\n虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新\n\nVirtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。\n尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。\n（2）跨平台\nVirtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。\n```"},"children":[]},{"data":{"id":"d005voyg6c80","created":1711098739113,"text":"虚拟DOM真的比真实DOM的性能好吗","note":"首次渲染的时候，是有劣势的，虚拟 DOM 首次大量渲染 DOM 时，\n会比 innerHTML 插入慢\n真实 DOM 正对性操作时，会更快\n\n```js\n首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。\n正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。\n```"},"children":[]},{"data":{"id":"d005vy68lc80","created":1711098759175,"text":"DIff算法的原理","note":"### 自己总结的 diff 算法\n\n触发 diff 算法的前提：\n更新被触发 dep.notify， patch 函数执行，对比新旧虚拟节点（是不是同类型、key 是否相等），如果不是同类型的标签，直接替换。如果是同类型的标签进行 patchVNode，对比新旧节点。\n1、patchVNode 四种情况：两边都没有子节点，直接对文本节点进行替换；旧的没有子节点，新的有子节点，加上新子节点；旧的有子节点，新的没有子节点，删除子节点；旧新都有子节点调用 updateChildren\n\ndiff 过程的描述：\n比较两组子节点是算法的重点，首先假设头尾节点可能相同做 4 次比对尝试，\n如果没有找到相同节点才按照通用方式遍历查找，查找结束再按情况处理剩下的节点；\n借助 key 通常可以非常精确找到相同节点，因此整个 patch 过程非常高效。\n\n### 50K 前端大牛总结的 diff 算法\n\ndiff 算法的前提一定是同层级和同类型的节点，核心就是两个列表的 diff，就是加上 key 之后的元素创建、移动、删除。\nvue2.0 中使用的是双端交叉指针，新老 VNode 各有两个指针，分别是队头与队头，队尾与队尾，队头与队尾，队尾与队头。交叉对比四次，如果匹配到元素就会移动节点进行复用，并且会将指针向中间移动。如果这四次对比都没有匹配到的时候，会从 Vdom 的队头开始，在老的 VNode 队列头部开始按照顺序查找，进行相应的删除、移动、创建。\n\nvue3.0 叫做双端快速 diff，也有两个指针。但是只对比两个情况队头和队头，队尾和队尾。如果能能够匹配上就和 vue2.0 一样操作，如果没有匹配上就“触发对新的 VDOM 去进行最长递增子序列的计算”，就是在新的队列里面寻找，依次递增的元素有哪些。找到之后，这些元素的顺序是固定的，去寻找不在这些序列表里面的元素，和老的 VDOM 进行对比，在进行移动删除和创建"},"children":[]},{"data":{"id":"d005w3pt1280","created":1711098771243,"text":"vue中key 的作用","note":"发生变化的时候 dep.notify 之后会调用 patch 函数，patch 会根据是否是否是同类型标签 和 key 值判断两个 VNode 是否为一个节点，如果 Key 不相同就可以直接插入新节点，删除旧结点。如果没有 key 就需要执行 patchVNode 去对比其他内容。（使得整个 patch 过程更加高效，）\n\n为了做唯一标识。为了高效渲染虚拟 DOM。key 是 vue 中 VNode 的唯一标志，通过这个 key ,diff 操作可以更加准确快速"},"children":[]},{"data":{"id":"d005waeo98w0","created":1711098785807,"text":"为什么不建议使用index作为key","note":"\n因为数组的 index 永远是 0，1，2，3 这样，数组删除、增加一项，key 就会受影响\n变化，会导致 vue 复用错误旧结点，多做额外的工作\n"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}