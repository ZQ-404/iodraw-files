{"root":{"data":{"id":"d0054b7wc740","created":1711096593377,"text":"vue"},"children":[{"data":{"id":"d00558d6rww0","created":1711096665531,"text":"vue基础","layout_mind_offset":{"x":-51.99999845027958,"y":806.9999900162225}},"children":[{"data":{"id":"d0055hcx99c0","created":1711096685106,"text":"vue的基本原理","note":"数据劫持和发布者订阅者模式。\n创建 vue 实例的时候，会遍历 data 中的数据进行 Object.definepropty();\ngetter/setter,数据会被劫持，读和写数据的时候会触发。\n然后就是发布和订阅模式。\n（render 在渲染虚拟树的时候，触发 getter ，getter 会触发依赖收集，给到 watcher。\n这边 setter 触发之后，会通知给到 watcher，re-render 触发 render 函数，重新收集依赖给到 watcher）"},"children":[]},{"data":{"id":"d0055merviw0","created":1711096696102,"text":"双向数据绑定的原理","note":"关键字解释：\nObserve 负责将一个普通对象转换成响应式对象。（complie getter(dep.addDep(Dep.target));(obeserve setter(dep.notify()通知更新依赖，通知 watcher 更新视图))\n\nWatcher 监听变化。watcher 在实例化的时候会将自己添加到 Dep 中，最后回调触发 render 函数。\n\nDep 依赖收集者 ，管理 watcher。数据发生变化时,会通知 watcher。\n\n数据触发视图：\nObserver --通知变化--->Dep（收集新的依赖）---通知变化--> Watcher（收更新集之后，触发视图更新） ----->View\n\n视图触发数据（两条线）：\n= Compile(--------> Watcher （订阅者，拿到之后绑定更新函数 ，对数据进行写入）-->dep (属性依赖收集)\n==compile ---->view 视图更新"},"children":[]},{"data":{"id":"d0055vfb3cw0","created":1711096715725,"text":"使用Object.defineProperty 进行数据劫持有什么特点","note":"需要循环递归来完成完整的劫持，消耗性能。\n\n并且初始化之后，新增属性不能被劫持。使用下标操作数组不能被劫持到。\n\n对比 VUE3 使用的 proxy 就解决了这些问题，但是缺点是 ES6 语法，没办法很好的兼容"},"children":[]},{"data":{"id":"d0056bzg3080","created":1711096751771,"text":"MVVM、MVC、MVP设计模式的区别","note":"MVC 数据驱动视图 \n当 view 层有动作，（动作指令作用在controller）controller 层的动作指令会上传到 （选择模型）model 层（驱动视图更新）\n\n\nMVVM 数据视图双向驱动\nview 有动作会触发model层\n当 model 层出现变化，也会触发 view 更新\n\n\n\n"},"children":[]},{"data":{"id":"d0056qlr2cg0","created":1711096783595,"text":"computed和watch的区别","note":"computed 是读缓存的，性能消耗小，当依赖数据发生改变时触发，不支持异步\n\nwatch 没有缓存，性能消耗大，自身变换触发，支持异步"},"children":[]},{"data":{"id":"d0056xm9hso0","created":1711096798864,"text":"computed和methods的区别","note":"computed 依赖的属性变化是触发\nmethods 调用的时候触发"},"children":[]},{"data":{"id":"d00575h9szk0","created":1711096815976,"text":"slot是什么？作用是什么？原理是什么？","note":"插槽：封装组件的时候预留的。使用的时候可以往里面插入内容。\n插槽分成三种：默认、具名、作用域\n\n默认（匿名）插槽\n\n```html\n<slot ><slot>\n<left><template></tempalte></left>\n```\n\n具名插槽\n\n```html\n<slot name=\"slotname\"></slot> <left> <template #slotname> </template> </left>\n```\n\n作用域插槽\n\n```html\n<slot name=\"slotname\" age=\"12\" name=\"zhangsan\"> </slot>\n<left>\n  <template #slotname=\"scope\"> {{scope.name}} {{scope.age}} </template>\n</left>\n```\n\n原理：。。"},"children":[]},{"data":{"id":"d0057gcycq80","created":1711096839659,"text":"过滤器的作用？如何实现一个过滤器？","note":"可以让一个数据不改变值的情况下，以另一种形式展示\n与 data 同级下面使用\n\n```js\nfilters:{\n\tgetNumber(value){\n\t\treturn value ;\n\t},\n}\n```\n\n使用插值表达式和管道符搭配使用 {{value | getNumber}}"},"children":[]},{"data":{"id":"d0057vol0d40","created":1711096873014,"text":"如何保存页面当前的状态？","note":"页面销毁\n存储到浏览器本地 sessionstorage localstorage\n路由传值，路由拿值\n页面不销毁\nkeepalive 进入生命周期 activated 、deactivated"},"children":[]},{"data":{"id":"d005817koeg0","created":1711096885047,"text":"常见的事件修饰符和作用","note":".stop 阻止冒泡 阻断内部冒泡\n.prevent 阻止默认行为\n.capture 阻止事件捕获\n.self 忽略内部冒泡事件带节奏，只响应自身事件  \n.once 值触发一次"},"children":[]},{"data":{"id":"d0058kk1h800","created":1711096927159,"text":"v-if、v-show、v-html的原理","note":"vif 不进行 render\nvshow display:none\nv-html   新建一个DOM元素，修改innerHTML的属性值"},"children":[]},{"data":{"id":"d0058xtmbmo0","created":1711096956037,"text":"v-if 和 v-show的区别","note":"vif 删除和添加 DOM，会造成重构，更消耗切换消耗，元素被删除\n\nvshow 给元素设置属性，会造成重绘，消耗除渲染消耗，元素被隐藏，占文档位置\n通过display：none的属性"},"children":[]},{"data":{"id":"d00593kqxrc0","created":1711096968561,"text":"v-model的语法糖怎么写的","note":"<v-input :value='message' @input='message=$event.target.value'>"},"children":[]},{"data":{"id":"d0059pmnrkw0","created":1711097016566,"text":"v-model能不能再自定义组件上使用？怎么去使用？"},"children":[]},{"data":{"id":"d005a5tqz340","created":1711097051823,"text":"data为什么是一个函数不是一个对象","note":"封装成函数，存在函数作用域，组件复用的时候，数据读写就不会相互干扰。"},"children":[]},{"data":{"id":"d005ar1w6kg0","created":1711097098028,"text":"keep-alive的理解、实现。具体缓存的内容是什么？","note":"三个属性\ninclude 正则表达式、字符串\nexclude\nmax 数字，字符数字，达到最大，前面组价会被 move 掉，\n最新进来的继续 keepalive"},"children":[]},{"data":{"id":"d005b90q3xs0","created":1711097137139,"text":"$nextTick的原理和作用","note":"最新的 DOM 元素渲染完成之后，执行。作用：\ncreated()钩子函数中，页面的 DOM 还未渲染，这时候也没办法操作 DOM，所以，此时如果想要操作 DOM，必须将操作的代码放在 nextTick()的回调函数中。"},"children":[]},{"data":{"id":"d005bngcqps0","created":1711097168559,"text":"vue2 中给对象中添加新的属性会发生什么？怎么去解决？","note":"因为 vue2 拦截是用的是 Object.definProperty(),初始化的时候会对数据进行劫持\n后面加的对象属性，不是响应式的，数据更新但视图不会更新\n解决方法\nthis.$set(this.obj,'b','dkkd')\n如果是 VUE3 使用的 proxy 就不会出问题"},"children":[]},{"data":{"id":"d005c9u6on40","created":1711097217285,"text":"vue中封装的数组方法有哪些？其是怎么实现页面更新的","note":"vue 使用的是 Object.defineProperty 这个方法没有办法对数据的内部进行监听\n需要经过特殊的处理，将 JS 数组的原生方法汇总成数组，只要匹配到就对数组\n数据进行操作 push pop unshift shift splice sort reverse"},"children":[]},{"data":{"id":"d005dl1ajxc0","created":1711097320023,"text":"vue单页面和多页面的区别","note":"SPA 表示单页面开发，加载一次资源，刷新局部资源即可，路由模型 hash history，数据传输VUEX,前期劳动成本高，后期维护成本低。\n\n\n\n\nMPA 表示多页面开发，多次发 http 请求资源费钱，路由只能普通跳转链接，数据传输cookie localStorage ，前期劳动成本低，后期维护成本高。\n\n\n\n扩展 SSR 服务端渲染， SEO 搜索引擎优化\n(SPA 不利于 SEO，可以借助 SSR 优化)MPA 是利于 SEO 的。"},"children":[]},{"data":{"id":"d005dtjyv800","created":1711097338567,"text":"vue template 到 render的过程","note":"template==>ast（抽象语法树）==>render\n\n\n第一步：调用 parse 方法将 template，type 参数分别调用表达式、纯文本、普通元素对应的方法，生成 ast 树。\n\n第二步：对静态节点做优化 optimize(ast,options) 对 ast 数进行深度遍历，摘除静态节点，为后续的模板更新做 优化。\n\n\n"},"children":[]},{"data":{"id":"d005e7k7kso0","created":1711097369056,"text":"vue中某个对象属性的值发生改变，视图会立即同步渲染吗"},"children":[]},{"data":{"id":"d005elojfw80","created":1711097399793,"text":"简述mixin和extends的覆盖原理"},"children":[]},{"data":{"id":"d005f4j4sbk0","created":1711097440825,"text":"描述vue的自定义指令"},"children":[]},{"data":{"id":"d005fxez2ko0","created":1711097503700,"text":"子组件可以直接修改父组件内部的数据吗"},"children":[]},{"data":{"id":"d005gbp011k0","created":1711097534781,"text":"vue是如何收集依赖的"},"children":[]},{"data":{"id":"d005glpp6dk0","created":1711097556592,"text":"vue的优点"},"children":[]},{"data":{"id":"d005gq5c31c0","created":1711097566244,"text":"assets 和  static的区别"},"children":[]},{"data":{"id":"d005h7kjeao0","created":1711097604169,"text":"delete 和  vue.delete 删除数组的区别"},"children":[]},{"data":{"id":"d005htom9fk0","created":1711097652305,"text":"vue如何监听对象或者数组中某个属性的变化"},"children":[]},{"data":{"id":"d005i5ta1rk0","created":1711097678708,"text":"什么是mixin"},"children":[]},{"data":{"id":"d005ib9hd9k0","created":1711097690571,"text":"vue 模板编译的原理"},"children":[]},{"data":{"id":"d005ihxi0v40","created":1711097705084,"text":"对SSR的理解"},"children":[]},{"data":{"id":"d005imfx3ew0","created":1711097714905,"text":"vue的性能优化有哪些"},"children":[]},{"data":{"id":"d005ite7okw0","created":1711097730040,"text":"对SPA单页面的理解，他的优缺点分别是什么"},"children":[]},{"data":{"id":"d005j97gbxc0","created":1711097764459,"text":"vue初始化页面闪动的原因和解决"},"children":[]},{"data":{"id":"d005jti10ls0","created":1711097808634,"text":"mixin和mixins的区别"},"children":[]},{"data":{"id":"d005k2l484o0","created":1711097828412,"text":"extend有什么作用"},"children":[]},{"data":{"id":"d005k9ptimw0","created":1711097843934,"text":"MVVM的有缺陷点"},"children":[]}]},{"data":{"id":"d005koblapk0","created":1711097875725,"text":"生命周期","layout_mind_offset":{"x":-1110.2499593682605,"y":-1350.9999771416192}},"children":[{"data":{"id":"d005m300wi00","created":1711097986042,"text":"简单说一下vue的生命周期"},"children":[]},{"data":{"id":"d005mcaol400","created":1711098006277,"text":"vue中子组件和父组件的执行顺序"},"children":[]},{"data":{"id":"d005mnxzw5s0","created":1711098031632,"text":"created和mounted的区别"},"children":[]},{"data":{"id":"d005mv5dcuo0","created":1711098047315,"text":"一般使用哪个生命周期去请求异步数据"},"children":[]},{"data":{"id":"d005n5cmqj40","created":1711098069522,"text":"keepalive和生命周期"},"children":[]}]},{"data":{"id":"d005ksl5pm00","created":1711097885011,"text":"组件通信的方式","layout_mind_offset":{"x":-1322.9999605715284,"y":-576.9999962151053}},"children":[]},{"data":{"id":"d005l211ehs0","created":1711097905562,"text":"路由","layout_mind_offset":{"x":-1258.9999624788768,"y":-151.00000891089405}},"children":[{"data":{"id":"d005o0wuv940","created":1711098138225,"text":"Vue-Router的懒加载如何实现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005o8431aw0","created":1711098153900,"text":"hash和history模式的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005ohg5jug0","created":1711098174221,"text":"如何获取页面hash的变化","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oms79e80","created":1711098185833,"text":"route和$router 的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oy9c1400","created":1711098210813,"text":"如何获取动态路由？如何获取传过来的动态参数？","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005pedfr6o0","created":1711098245890,"text":"vue-Router路由钩子在生命周期中的体现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005prrucqo0","created":1711098275059,"text":"vue-router跳转和location.herf的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q1xngcg0","created":1711098297178,"text":"params和query的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q95kty80","created":1711098312895,"text":"vue-router的导航守卫有哪些","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005qjw0dz40","created":1711098336261,"text":"对前端路由的理解","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]}]},{"data":{"id":"d005l8fnfsw0","created":1711097919507,"text":"vuex","layout_mind_offset":{"x":-489.9999853968625,"y":-317.99999052286176}},"children":[{"data":{"id":"d005qzcn6w00","created":1711098369919,"text":"vuex的原理和自己的理解"},"children":[]},{"data":{"id":"d005rd6jcqo0","created":1711098400024,"text":"vue中action和mutation的区别"},"children":[]},{"data":{"id":"d005rpym3mg0","created":1711098427843,"text":"vuex和localstorage的 区别"},"children":[]},{"data":{"id":"d005rzn1do80","created":1711098448911,"text":"vuex有哪些属性"},"children":[]},{"data":{"id":"d005sa2j9940","created":1711098471616,"text":"vuex和单纯的全局对象有什么区别"},"children":[]},{"data":{"id":"d005sk0m9wg0","created":1711098493268,"text":"为什么不能再vuex的mutation中做异步操作"},"children":[]},{"data":{"id":"d005ssblpqg0","created":1711098511347,"text":"vuex中严格模式的作用，如何开启"},"children":[]},{"data":{"id":"d005t61v9dk0","created":1711098541233,"text":"如何批量使用vuex的getter属性"},"children":[]},{"data":{"id":"d005tf5mmmo0","created":1711098561051,"text":"如何在组件中重复使用vuex的mutation"},"children":[]}]},{"data":{"id":"d005lbsvtw00","created":1711097926837,"text":"vue3.0","layout_mind_offset":{"x":-697.9999791979795,"y":-321.9999904036524}},"children":[{"data":{"id":"d005u33dijk0","created":1711098613158,"text":"vue3 有哪些更新"},"children":[]},{"data":{"id":"d005u8uftkw0","created":1711098625678,"text":"dfineProperty和Proxy的区别"},"children":[]},{"data":{"id":"d005uiscqao0","created":1711098647320,"text":"vue3为什么要使用proxy"},"children":[]},{"data":{"id":"d005uqu2e680","created":1711098664838,"text":"vue3中compositionAPI"},"children":[]}]},{"data":{"id":"d005lfaqkxc0","created":1711097934447,"text":"虚拟DOM","layout_mind_offset":{"x":-697.9999791979797,"y":-193.9999942183495}},"children":[{"data":{"id":"d005v7utas00","created":1711098701888,"text":"对虚拟DOM的理解"},"children":[]},{"data":{"id":"d005vc8lkv40","created":1711098711429,"text":"虚拟DOM的解析过程"},"children":[]},{"data":{"id":"d005vk1o35s0","created":1711098728424,"text":"为什么要用虚拟DOM"},"children":[]},{"data":{"id":"d005voyg6c80","created":1711098739113,"text":"虚拟DOM真的比真实DOM的性能好吗"},"children":[]},{"data":{"id":"d005vy68lc80","created":1711098759175,"text":"DIff算法的原理"},"children":[]},{"data":{"id":"d005w3pt1280","created":1711098771243,"text":"vue中key 的作用"},"children":[]},{"data":{"id":"d005waeo98w0","created":1711098785807,"text":"为什么不建议使用index作为key"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}