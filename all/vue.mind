{"root":{"data":{"id":"d0054b7wc740","created":1711096593377,"text":"vue"},"children":[{"data":{"id":"d00558d6rww0","created":1711096665531,"text":"vue基础","layout_mind_offset":{"x":-51.99999845027958,"y":806.9999900162225}},"children":[{"data":{"id":"d0055hcx99c0","created":1711096685106,"text":"vue的基本原理","note":"数据劫持和发布者订阅者模式。\n创建 vue 实例的时候，会遍历 data 中的数据进行 Object.definepropty();\ngetter/setter,数据会被劫持，读和写数据的时候会触发。\n然后就是发布和订阅模式。\n（render 在渲染虚拟树的时候，触发 getter ，getter 会触发依赖收集，给到 watcher。\n这边 setter 触发之后，会通知给到 watcher，re-render 触发 render 函数，重新收集依赖给到 watcher）"},"children":[]},{"data":{"id":"d0055merviw0","created":1711096696102,"text":"双向数据绑定的原理","note":"关键字解释：\nObserve 负责将一个普通对象转换成响应式对象。（complie getter(dep.addDep(Dep.target));(obeserve setter(dep.notify()通知更新依赖，通知 watcher 更新视图))\n\nWatcher 监听变化。watcher 在实例化的时候会将自己添加到 Dep 中，最后回调触发 render 函数。\n\nDep 依赖收集者 ，管理 watcher。数据发生变化时,会通知 watcher。\n\n数据触发视图：\nObserver --通知变化--->Dep（收集新的依赖）---通知变化--> Watcher（收更新集之后，触发视图更新） ----->View\n\n视图触发数据（两条线）：\n= Compile(--------> Watcher （订阅者，拿到之后绑定更新函数 ，对数据进行写入）-->dep (属性依赖收集)\n==compile ---->view 视图更新"},"children":[]},{"data":{"id":"d0055vfb3cw0","created":1711096715725,"text":"使用Object.defineProperty 进行数据劫持有什么特点","note":"需要循环递归来完成完整的劫持，消耗性能。\n\n并且初始化之后，新增属性不能被劫持。使用下标操作数组不能被劫持到。\n\n对比 VUE3 使用的 proxy 就解决了这些问题，但是缺点是 ES6 语法，没办法很好的兼容"},"children":[]},{"data":{"id":"d0056bzg3080","created":1711096751771,"text":"MVVM、MVC、MVP设计模式的区别","note":"MVC 数据驱动视图 \n当 view 层有动作，（动作指令作用在controller）controller 层的动作指令会上传到 （选择模型）model 层（驱动视图更新）\n\n\nMVVM 数据视图双向驱动\nview 有动作会触发model层\n当 model 层出现变化，也会触发 view 更新\n\n\n\n"},"children":[]},{"data":{"id":"d0056qlr2cg0","created":1711096783595,"text":"computed和watch的区别","note":"computed 是读缓存的，性能消耗小，当依赖数据发生改变时触发，不支持异步\n\nwatch 没有缓存，性能消耗大，自身变换触发，支持异步"},"children":[]},{"data":{"id":"d0056xm9hso0","created":1711096798864,"text":"computed和methods的区别","note":"computed 依赖的属性变化是触发\nmethods 调用的时候触发"},"children":[]},{"data":{"id":"d00575h9szk0","created":1711096815976,"text":"slot是什么？作用是什么？原理是什么？","note":"插槽：封装组件的时候预留的。使用的时候可以往里面插入内容。\n插槽分成三种：默认、具名、作用域\n\n默认（匿名）插槽\n\n```html\n<slot ><slot>\n<left><template></tempalte></left>\n```\n\n具名插槽\n\n```html\n<slot name=\"slotname\"></slot> <left> <template #slotname> </template> </left>\n```\n\n作用域插槽\n\n```html\n<slot name=\"slotname\" age=\"12\" name=\"zhangsan\"> </slot>\n<left>\n  <template #slotname=\"scope\"> {{scope.name}} {{scope.age}} </template>\n</left>\n```\n\n原理：。。"},"children":[]},{"data":{"id":"d0057gcycq80","created":1711096839659,"text":"过滤器的作用？如何实现一个过滤器？","note":"可以让一个数据不改变值的情况下，以另一种形式展示\n与 data 同级下面使用\n\n```js\nfilters:{\n\tgetNumber(value){\n\t\treturn value ;\n\t},\n}\n```\n\n使用插值表达式和管道符搭配使用 {{value | getNumber}}"},"children":[]},{"data":{"id":"d0057vol0d40","created":1711096873014,"text":"如何保存页面当前的状态？","note":"页面销毁\n存储到浏览器本地 sessionstorage localstorage\n路由传值，路由拿值\n页面不销毁\nkeepalive 进入生命周期 activated 、deactivated"},"children":[]},{"data":{"id":"d005817koeg0","created":1711096885047,"text":"常见的事件修饰符和作用","note":".stop 阻止冒泡 阻断内部冒泡\n.prevent 阻止默认行为\n.capture 阻止事件捕获\n.self 忽略内部冒泡事件带节奏，只响应自身事件  \n.once 值触发一次"},"children":[]},{"data":{"id":"d0058kk1h800","created":1711096927159,"text":"v-if、v-show、v-html的原理","note":"vif 不进行 render\nvshow display:none\nv-html   新建一个DOM元素，修改innerHTML的属性值"},"children":[]},{"data":{"id":"d0058xtmbmo0","created":1711096956037,"text":"v-if 和 v-show的区别","note":"vif 删除和添加 DOM，会造成重构，更消耗切换消耗，元素被删除\n\nvshow 给元素设置属性，会造成重绘，消耗除渲染消耗，元素被隐藏，占文档位置\n通过display：none的属性"},"children":[]},{"data":{"id":"d00593kqxrc0","created":1711096968561,"text":"v-model的语法糖怎么写的","note":"<v-input :value='message' @input='message=$event.target.value'>"},"children":[]},{"data":{"id":"d0059pmnrkw0","created":1711097016566,"text":"v-model能不能再自定义组件上使用？怎么去使用？"},"children":[]},{"data":{"id":"d005a5tqz340","created":1711097051823,"text":"data为什么是一个函数不是一个对象","note":"封装成函数，存在函数作用域，组件复用的时候，数据读写就不会相互干扰。"},"children":[]},{"data":{"id":"d005ar1w6kg0","created":1711097098028,"text":"keep-alive的理解、实现。具体缓存的内容是什么？","note":"三个属性\ninclude 正则表达式、字符串\nexclude\nmax 数字，字符数字，达到最大，前面组价会被 move 掉，\n最新进来的继续 keepalive"},"children":[]},{"data":{"id":"d005b90q3xs0","created":1711097137139,"text":"$nextTick的原理和作用","note":"最新的 DOM 元素渲染完成之后，执行。作用：\ncreated()钩子函数中，页面的 DOM 还未渲染，这时候也没办法操作 DOM，所以，此时如果想要操作 DOM，必须将操作的代码放在 nextTick()的回调函数中。"},"children":[]},{"data":{"id":"d005bngcqps0","created":1711097168559,"text":"vue2 中给对象中添加新的属性会发生什么？怎么去解决？","note":"因为 vue2 拦截是用的是 Object.definProperty(),初始化的时候会对数据进行劫持\n后面加的对象属性，不是响应式的，数据更新但视图不会更新\n解决方法\nthis.$set(this.obj,'b','dkkd')\n如果是 VUE3 使用的 proxy 就不会出问题"},"children":[]},{"data":{"id":"d005c9u6on40","created":1711097217285,"text":"vue中封装的数组方法有哪些？其是怎么实现页面更新的","note":"vue 使用的是 Object.defineProperty 这个方法没有办法对数据的内部进行监听\n需要经过特殊的处理，将 JS 数组的原生方法汇总成数组，只要匹配到就对数组\n数据进行操作 push pop unshift shift splice sort reverse"},"children":[]},{"data":{"id":"d005dl1ajxc0","created":1711097320023,"text":"vue单页面和多页面的区别","note":"SPA 表示单页面开发，加载一次资源，刷新局部资源即可，路由模型 hash history，数据传输VUEX,前期劳动成本高，后期维护成本低。\n\n\n\n\nMPA 表示多页面开发，多次发 http 请求资源费钱，路由只能普通跳转链接，数据传输cookie localStorage ，前期劳动成本低，后期维护成本高。\n\n\n\n扩展 SSR 服务端渲染， SEO 搜索引擎优化\n(SPA 不利于 SEO，可以借助 SSR 优化)MPA 是利于 SEO 的。"},"children":[]},{"data":{"id":"d005dtjyv800","created":1711097338567,"text":"vue template 到 render的过程","note":"template==>ast（抽象语法树）==>render\n\n\n第一步：调用 parse 方法将 template，type 参数分别调用表达式、纯文本、普通元素对应的方法，生成 ast 树。\n\n第二步：对静态节点做优化 optimize(ast,options) 对 ast 数进行深度遍历，摘除静态节点，为后续的模板更新做 优化。\n\n\n第三步：generate(ast,options) ast 通过 generate 被编译成 render 字符串。在通过 new Function（'render'） 生成函数，方便调用执行。"},"children":[]},{"data":{"id":"d005e7k7kso0","created":1711097369056,"text":"vue中某个对象属性的值发生改变，视图会立即同步渲染吗","note":"不会。为了减少性能消耗，vue 有一个去重机制。watcher 被触发之后会进入事件队列,事件队列去重之后才回去执行视图渲染的工作。"},"children":[]},{"data":{"id":"d005elojfw80","created":1711097399793,"text":"简述mixin和extends的覆盖原理","note":"都是通过 mergeOptions 方法去实现的\nmixins接收一个混入对象的数组，在调用组件自身的钩子之前被调用。\nextends接收一个对象或构造函数，（如下面写法不同）\n\nmixins: [mixin1, mixin2],\nextends: extend,\n合并策略 1 ：先 mixin 和 extend 里面的回调 然后再调用组件自身的回调 ； hooks 生命周期钩子函数，先执行 mixins 和 extend 是里面的，然后再执行自身的\n合并策略 2：其他的 options 都是将 将组件上没有的合并上去，有的使用默认的值\n\n1、watch 以及生命钩子函数的执行顺序，先执行 mixins 和 extends 里面的，再去执行自身的\n2、mergeOptions 对 vue 实例中的 options 依次进行合并，新定义一个 options ，并将这个 新 options 返回出去"},"children":[]},{"data":{"id":"d005f4j4sbk0","created":1711097440825,"text":"描述vue的自定义指令","note":"虽然 vue 不推崇操作 DOM，但是在复杂的业务环境中，操作 DOM 也是难免的，这个时候就可以使用自定义指令去操作 DOM\n全面自定义指令：Vue.directive(\"xxx\",{})\n局部自定义指令 :directive:{'xxx':{}}\n常用的钩子函数有 bind mounted update componentUpdated unbind\n这些钩子函数在不同的生命周期中被调用\n比如下面的自定义指令代码\n\n```js\ndiretive:{\n  loading:{\n    inserted(el,binding){\n      // el  表示当前被绑定自定义指令的元素节点\n      // binding 表示自定义指令时传入的参数\n      // binding.value 其实就是  isShow 的值\n\n    },\n    update(el,binding){\n\n    },\n  }\n}\n```\n\n```html\n<div v-loading=\"isShow\"></div>\n```"},"children":[]},{"data":{"id":"d005fxez2ko0","created":1711097503700,"text":"子组件可以直接修改父组件内部的数据吗","note":"不可以，以为 VUE 提倡单向数据流，防止数据流混乱。\n允许父修改子数据，如果需要修改通过$emit"},"children":[]},{"data":{"id":"d005gbp011k0","created":1711097534781,"text":"vue是如何收集依赖的","note":"data 初始化的时候，会进行数据拦截，会在这个时候进行依赖收集"},"children":[]},{"data":{"id":"d005gq5c31c0","created":1711097566244,"text":"assets 和  static的区别","note":"相同点：都是储存静态资源文件的地方\n\n不同点：assets 在项目打包的时候会被打包、static 不会被打包\n\n项目中自己写的 JS 可以放在 assets 中，引入的第三方 JS 文件放到 static 中."},"children":[]},{"data":{"id":"d005h7kjeao0","created":1711097604169,"text":"delete 和  vue.delete 删除数组的区别","note":"不同点：\ndelete 删除的元素变成 undefined/empty 。\nVue.delete 直接删除数组，改变数组键值对。\n代码如下：\nlet arr = [1, 2, 3, 4, 5]\ndelete arr[2] //输出 arr 为 👉[1, 2, empty, 4, 5]\nVue.delete(arr, 2) //输出 arr 为 👉[1, 2, 4, 5]\n\n\n相同点：\n删除对象属性的时候，输出的内容是一样的。但是 vue.delete 删除之后可以触发视图更新，delete 删除之后视图得不到更新\nlet obj = { name: 'zs', age: 12 }\nVue.delete(obj, 'name'); //输出obj为👉{age: 12}\ndelete obj.name; //输出obj为👉{age: 12}\n"},"children":[]},{"data":{"id":"d005htom9fk0","created":1711097652305,"text":"vue如何监听对象或者数组中某个属性的变化","note":"vue2 监听不到属性的变化、this.$set(数组/对象，索引/属性，值)\n对象会判断是不是响应式属性，如果是响应式就直接操作，不是响应式就需要对属性进行数据劫持，添加响应式\n\n数组会调用 splice，或者调用数组的原型链，vue 源码中对数组操作的方法进行了重写。听过匹配重写的数组方法也可以触发响应式"},"children":[]},{"data":{"id":"d005i5ta1rk0","created":1711097678708,"text":"什么是mixin","note":"vue 组件中进行插拔和复用。如果需要使用，只需要引入文件，\n放入 mixin 中 ，就能混入到组件中，可以直接用 this 去调用，非常方便\n扩展 mixin 和 mixins 的区别，mixin 是全局混入的写法，mixins 是局部引入的写法。\n\n```js\n// main.js\nimport mixin from \"./mixin.js\";\nVue.mixin(mixin);\n\n// 单个vue文件\nimport { myMixin } from \"./mixin.js\";\nexport default {\n  mixins: [myMixin];\n}\n```"},"children":[]},{"data":{"id":"d005ib9hd9k0","created":1711097690571,"text":"vue 模板编译的原理","note":"(三个阶段：解析阶段、优化阶段、生成阶段)\n\n\ntemplate 无法直接被浏览器解析并渲染，需要解析 parse、\noptimize 优化成 generate\n然后执行 render 函数"},"children":[]},{"data":{"id":"d005ihxi0v40","created":1711097705084,"text":"对SSR的理解","note":"服务端渲染。vue 在服务端将代码渲染成超文本语言，然后将渲染好的 HTML\n返回给客户端。\n优点：可以优化SPA的 SEO 、首屏加载速度更快\n缺点：更多的服务端负载、需要 node.js 运行环境、\n开发条件收到限制，只支持 beforCreate 和 created 两个钩子函数。"},"children":[]},{"data":{"id":"d005imfx3ew0","created":1711097714905,"text":"vue的性能优化有哪些","note":"(1)编码阶段\n1、减少 data 中的数据，因为 vue 实例化的时候会对 getter 和 setter、会消耗性能\n2、vif 和 vfor 不能连用\n因为 vue2 中 vfor 的优先级是高于 vif，所以如果连用，会先执行 vfor，\n然后逐个执行 vif，vif 是性能消耗比较高。\nvue3 中 vif 优先级高于与 vfor 是可以连用的\nvue2 中解决方法，① 对 list 进行过滤 ②vif 包裹在外面\n3、不适用 vfor 对元素进行逐个绑定事件，可以使用事件代理的方式\n在子元素上绑定指定以属性<div v-for='item in list ' :key='item' :data-XXX='item' ></div>，\n在父元素上绑定点击事件 @click='onClick(e)'，\n通过 e.target.getAttribute('data-XXX');\n获取子元素的属性值\n4、SPA 页面使用 keepalive 缓存组件\n5、如果不是频繁切换，使用 vif 代替 vshow\n6、使用 key、 保证 DOM 的唯一性\n7、使用路由懒加载，异步加载组件。\nwebpack 会将 vue 打包成单独的 JS 文件，\n当请求发出之后，在对相应的路由进行请求发送\n8、防抖、节流\n防抖：第一次 A 事件和第二次 B 事件，他们之间时间间隔需要在指定时间内，\n多次触发同一个事件，只执行最后一次操作。比如输入框中输入数据，将一段时间内的多次触发，合并成最后一次\n才会执行 A 事件\n节流：保护时间内只执行一个 A 事件，保护时间结束再去执行 B 事件\n多次触发同一个事件，只执行第一次操作。\n9、第三模块按需引入\n10、长列表动态化加载(分页)\n11、图片懒加载\n\n(2)SEO 优化\n1、预渲染\n2、服务端渲染 SSR\n\n(3)打包优化\n1、压缩代码\n2、Tree Shaking/Scope Hoisting\n3、使用 CDN 加载第三方模块\n4、多线程打包 happypack\n5、splitChunks 抽离公共文件\n6、sourceMap 优化\n(4)用户体验\n骨架屏\nPWA\n还可以使用缓存 客户端缓存、服务端缓存"},"children":[]},{"data":{"id":"d005ite7okw0","created":1711097730040,"text":"对SPA单页面的理解，他的优缺点分别是什么"},"children":[]},{"data":{"id":"d005j97gbxc0","created":1711097764459,"text":"vue初始化页面闪动的原因和解决"},"children":[]},{"data":{"id":"d005jti10ls0","created":1711097808634,"text":"mixin和mixins的区别"},"children":[]},{"data":{"id":"d005k2l484o0","created":1711097828412,"text":"extend有什么作用"},"children":[]},{"data":{"id":"d005k9ptimw0","created":1711097843934,"text":"MVVM的有缺陷点"},"children":[]}]},{"data":{"id":"d005koblapk0","created":1711097875725,"text":"生命周期","layout_mind_offset":{"x":-1110.2499593682605,"y":-1350.9999771416192}},"children":[{"data":{"id":"d005m300wi00","created":1711097986042,"text":"简单说一下vue的生命周期"},"children":[]},{"data":{"id":"d005mcaol400","created":1711098006277,"text":"vue中子组件和父组件的执行顺序"},"children":[]},{"data":{"id":"d005mnxzw5s0","created":1711098031632,"text":"created和mounted的区别"},"children":[]},{"data":{"id":"d005mv5dcuo0","created":1711098047315,"text":"一般使用哪个生命周期去请求异步数据"},"children":[]},{"data":{"id":"d005n5cmqj40","created":1711098069522,"text":"keepalive和生命周期"},"children":[]}]},{"data":{"id":"d005ksl5pm00","created":1711097885011,"text":"组件通信的方式","layout_mind_offset":{"x":-1322.9999605715284,"y":-576.9999962151053}},"children":[]},{"data":{"id":"d005l211ehs0","created":1711097905562,"text":"路由","layout_mind_offset":{"x":-1258.9999624788768,"y":-151.00000891089405}},"children":[{"data":{"id":"d005o0wuv940","created":1711098138225,"text":"Vue-Router的懒加载如何实现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005o8431aw0","created":1711098153900,"text":"hash和history模式的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005ohg5jug0","created":1711098174221,"text":"如何获取页面hash的变化","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oms79e80","created":1711098185833,"text":"route和$router 的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005oy9c1400","created":1711098210813,"text":"如何获取动态路由？如何获取传过来的动态参数？","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005pedfr6o0","created":1711098245890,"text":"vue-Router路由钩子在生命周期中的体现","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005prrucqo0","created":1711098275059,"text":"vue-router跳转和location.herf的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q1xngcg0","created":1711098297178,"text":"params和query的区别","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005q95kty80","created":1711098312895,"text":"vue-router的导航守卫有哪些","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]},{"data":{"id":"d005qjw0dz40","created":1711098336261,"text":"对前端路由的理解","layout_left_offset":{"x":-600.9999820888047,"y":75.99999773502356}},"children":[]}]},{"data":{"id":"d005l8fnfsw0","created":1711097919507,"text":"vuex","layout_mind_offset":{"x":-489.9999853968625,"y":-317.99999052286176}},"children":[{"data":{"id":"d005qzcn6w00","created":1711098369919,"text":"vuex的原理和自己的理解"},"children":[]},{"data":{"id":"d005rd6jcqo0","created":1711098400024,"text":"vue中action和mutation的区别"},"children":[]},{"data":{"id":"d005rpym3mg0","created":1711098427843,"text":"vuex和localstorage的 区别"},"children":[]},{"data":{"id":"d005rzn1do80","created":1711098448911,"text":"vuex有哪些属性"},"children":[]},{"data":{"id":"d005sa2j9940","created":1711098471616,"text":"vuex和单纯的全局对象有什么区别"},"children":[]},{"data":{"id":"d005sk0m9wg0","created":1711098493268,"text":"为什么不能再vuex的mutation中做异步操作"},"children":[]},{"data":{"id":"d005ssblpqg0","created":1711098511347,"text":"vuex中严格模式的作用，如何开启"},"children":[]},{"data":{"id":"d005t61v9dk0","created":1711098541233,"text":"如何批量使用vuex的getter属性"},"children":[]},{"data":{"id":"d005tf5mmmo0","created":1711098561051,"text":"如何在组件中重复使用vuex的mutation"},"children":[]}]},{"data":{"id":"d005lbsvtw00","created":1711097926837,"text":"vue3.0","layout_mind_offset":{"x":-697.9999791979795,"y":-321.9999904036524}},"children":[{"data":{"id":"d005u33dijk0","created":1711098613158,"text":"vue3 有哪些更新"},"children":[]},{"data":{"id":"d005u8uftkw0","created":1711098625678,"text":"dfineProperty和Proxy的区别"},"children":[]},{"data":{"id":"d005uiscqao0","created":1711098647320,"text":"vue3为什么要使用proxy"},"children":[]},{"data":{"id":"d005uqu2e680","created":1711098664838,"text":"vue3中compositionAPI"},"children":[]}]},{"data":{"id":"d005lfaqkxc0","created":1711097934447,"text":"虚拟DOM","layout_mind_offset":{"x":-697.9999791979797,"y":-193.9999942183495}},"children":[{"data":{"id":"d005v7utas00","created":1711098701888,"text":"对虚拟DOM的理解"},"children":[]},{"data":{"id":"d005vc8lkv40","created":1711098711429,"text":"虚拟DOM的解析过程"},"children":[]},{"data":{"id":"d005vk1o35s0","created":1711098728424,"text":"为什么要用虚拟DOM"},"children":[]},{"data":{"id":"d005voyg6c80","created":1711098739113,"text":"虚拟DOM真的比真实DOM的性能好吗"},"children":[]},{"data":{"id":"d005vy68lc80","created":1711098759175,"text":"DIff算法的原理"},"children":[]},{"data":{"id":"d005w3pt1280","created":1711098771243,"text":"vue中key 的作用"},"children":[]},{"data":{"id":"d005waeo98w0","created":1711098785807,"text":"为什么不建议使用index作为key"},"children":[]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}